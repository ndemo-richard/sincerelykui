"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_sanity_groq-store_dist_browser_groq-store_modern_mjs"],{

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!*************************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; },\n/* harmony export */   \"getType\": function() { return /* binding */ getType; },\n/* harmony export */   \"rebaseValue\": function() { return /* binding */ rebaseValue; },\n/* harmony export */   \"unwrap\": function() { return /* binding */ unwrap; },\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = /** @class */ (function () {\n    function Model(meta) {\n        this.meta = meta;\n    }\n    Model.prototype.wrap = function (data) {\n        return this.wrapWithMeta(data, this.meta, this.meta);\n    };\n    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {\n        if (endMeta === void 0) { endMeta = this.meta; }\n        return { data: data, startMeta: startMeta, endMeta: endMeta };\n    };\n    Model.prototype.asObject = function (value) {\n        if (!value.content) {\n            var fields = {};\n            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\n            }\n            value.content = { type: 'object', fields: fields };\n        }\n        return value.content;\n    };\n    Model.prototype.asArray = function (value) {\n        var _this = this;\n        if (!value.content) {\n            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });\n            var metas = elements.map(function () { return _this.meta; });\n            value.content = { type: 'array', elements: elements, metas: metas };\n        }\n        return value.content;\n    };\n    Model.prototype.asString = function (value) {\n        if (!value.content) {\n            var str = value.data;\n            var part = {\n                value: str,\n                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),\n                uses: [],\n                startMeta: value.startMeta,\n                endMeta: value.endMeta\n            };\n            value.content = this.stringFromParts([part]);\n        }\n        return value.content;\n    };\n    Model.prototype.stringFromParts = function (parts) {\n        var str = {\n            type: 'string',\n            parts: parts\n        };\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            part.uses.push(str);\n        }\n        return str;\n    };\n    Model.prototype.objectGetKeys = function (value) {\n        if (value.content) {\n            return Object.keys(value.content.fields);\n        }\n        else {\n            return Object.keys(value.data);\n        }\n    };\n    Model.prototype.objectGetField = function (value, key) {\n        var obj = this.asObject(value);\n        return obj.fields[key];\n    };\n    Model.prototype.arrayGetElement = function (value, idx) {\n        var arr = this.asArray(value);\n        return arr.elements[idx];\n    };\n    Model.prototype.finalize = function (content) {\n        this.updateEndMeta(content);\n        return { content: content, startMeta: this.meta, endMeta: this.meta };\n    };\n    Model.prototype.markChanged = function (value) {\n        return this.wrap(unwrap(value));\n    };\n    Model.prototype.updateEndMeta = function (content) {\n        if (content.type == 'string') {\n            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {\n                var part = _a[_i];\n                part.endMeta = this.meta;\n            }\n        }\n        else {\n            if (content.type === 'array') {\n                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {\n                    var val = _c[_b];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n            else {\n                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {\n                    var val = _e[_d];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n        }\n    };\n    Model.prototype.copyString = function (value) {\n        if (value) {\n            var other = this.asString(value);\n            return this.stringFromParts(other.parts.slice());\n        }\n        else {\n            return {\n                type: 'string',\n                parts: []\n            };\n        }\n    };\n    Model.prototype.copyObject = function (value) {\n        var obj = {\n            type: 'object',\n            fields: {}\n        };\n        if (value) {\n            var other = this.asObject(value);\n            Object.assign(obj.fields, other.fields);\n        }\n        return obj;\n    };\n    Model.prototype.copyArray = function (value) {\n        var arr = value ? this.asArray(value) : null;\n        var elements = arr ? arr.elements : [];\n        var metas = arr ? arr.metas : [];\n        return {\n            type: 'array',\n            elements: elements,\n            metas: metas\n        };\n    };\n    Model.prototype.objectSetField = function (target, key, value) {\n        target.fields[key] = value;\n    };\n    Model.prototype.objectDeleteField = function (target, key) {\n        delete target.fields[key];\n    };\n    Model.prototype.arrayAppendValue = function (target, value) {\n        target.elements.push(value);\n        target.metas.push(this.meta);\n    };\n    Model.prototype.arrayAppendSlice = function (target, source, left, right) {\n        var _a, _b;\n        var arr = this.asArray(source);\n        var samePosition = arr.elements.length === left;\n        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));\n        if (samePosition) {\n            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));\n        }\n        else {\n            for (var i = left; i < right; i++) {\n                target.metas.push(this.meta);\n            }\n        }\n    };\n    Model.prototype.stringAppendValue = function (target, value) {\n        var str = this.asString(value);\n        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {\n            var part = _a[_i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    Model.prototype.stringAppendPart = function (target, part) {\n        target.parts.push(part);\n        part.uses.push(target);\n    };\n    Model.prototype.resolveStringPart = function (str, from, len) {\n        if (len === 0)\n            return from;\n        for (var i = from; i < str.parts.length; i++) {\n            var part = str.parts[i];\n            if (len === part.utf8size) {\n                // Matches perfect!\n                return i + 1;\n            }\n            if (len < part.utf8size) {\n                // It's a part of this chunk. We now need to split it up.\n                this.splitString(part, len);\n                return i + 1;\n            }\n            len -= part.utf8size;\n        }\n        throw new Error('splitting string out of bounds');\n    };\n    Model.prototype.splitString = function (part, idx) {\n        var leftValue;\n        var rightValue;\n        var leftSize = idx;\n        var rightSize = part.utf8size - leftSize;\n        // idx is here in UTF-8 index, not codepoint index.\n        // This means we might to adjust for multi-byte characters.\n        if (part.utf8size !== part.value.length) {\n            var byteCount = 0;\n            for (idx = 0; byteCount < leftSize; idx++) {\n                var code = part.value.codePointAt(idx);\n                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);\n                if (size === 4)\n                    idx++; // Surrogate pair.\n                byteCount += size;\n            }\n        }\n        leftValue = part.value.slice(0, idx);\n        rightValue = part.value.slice(idx);\n        var newPart = {\n            value: rightValue,\n            utf8size: rightSize,\n            uses: part.uses.slice(),\n            startMeta: part.startMeta,\n            endMeta: part.endMeta\n        };\n        part.value = leftValue;\n        part.utf8size = leftSize;\n        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {\n            var use = _a[_i];\n            // Insert the new part.\n            var idx_1 = use.parts.indexOf(part);\n            if (idx_1 === -1)\n                throw new Error('bug: mismatch between string parts and use.');\n            use.parts.splice(idx_1 + 1, 0, newPart);\n        }\n    };\n    Model.prototype.stringAppendSlice = function (target, source, left, right) {\n        var str = this.asString(source);\n        var firstPart = this.resolveStringPart(str, 0, left);\n        var lastPart = this.resolveStringPart(str, firstPart, right - left);\n        for (var i = firstPart; i < lastPart; i++) {\n            var part = str.parts[i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    return Model;\n}());\n// Turns a native JavaScript object into a Value with a given origin.\nfunction wrap(data, meta) {\n    return { data: data, startMeta: meta, endMeta: meta };\n}\n// Converts a Value into a native JavaScript type.\nfunction unwrap(value) {\n    if (typeof value.data !== 'undefined')\n        return value.data;\n    var result;\n    var content = value.content;\n    switch (content.type) {\n        case 'string':\n            result = content.parts.map(function (part) { return part.value; }).join('');\n            break;\n        case 'array':\n            result = content.elements.map(function (val) { return unwrap(val); });\n            break;\n        case 'object': {\n            result = {};\n            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                result[key] = unwrap(val);\n            }\n        }\n    }\n    value.data = result;\n    return result;\n}\n// Returns the type of a Value.\nfunction getType(value) {\n    if (value.content)\n        return value.content.type;\n    if (Array.isArray(value.data))\n        return 'array';\n    if (value.data === null)\n        return 'null';\n    return typeof value.data;\n}\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\nfunction rebaseValue(left, right) {\n    var leftType = getType(left);\n    var rightType = getType(right);\n    if (leftType !== rightType)\n        return right;\n    var leftModel = new Model(left.endMeta);\n    var rightModel = new Model(right.endMeta);\n    switch (leftType) {\n        case 'object': {\n            var leftObj = leftModel.asObject(left);\n            var rightObj = rightModel.asObject(right);\n            // Number of fields which are identical in left and right.\n            var identicalFieldCount = 0;\n            var leftFieldCount = Object.keys(leftObj.fields).length;\n            var rightFieldCount = Object.keys(rightObj.fields).length;\n            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], rightVal = _b[1];\n                var leftVal = leftObj.fields[key];\n                if (leftVal) {\n                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n                    if (rightObj.fields[key] === leftVal) {\n                        identicalFieldCount++;\n                    }\n                }\n            }\n            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n            return isIdentical ? left : right;\n        }\n        case 'array': {\n            var leftArr = leftModel.asArray(left);\n            var rightArr = rightModel.asArray(right);\n            if (leftArr.elements.length !== rightArr.elements.length) {\n                break;\n            }\n            var numRebased = 0;\n            for (var i = 0; i < rightArr.elements.length; i++) {\n                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n                if (rightArr.elements[i] !== leftArr.elements[i]) {\n                    numRebased++;\n                }\n            }\n            return numRebased === 0 ? left : right;\n        }\n        case 'null':\n        case 'boolean':\n        case 'number': {\n            if (unwrap(left) === unwrap(right))\n                return left;\n            break;\n        }\n        case 'string': {\n            var leftRaw = unwrap(left);\n            var rightRaw = unwrap(right);\n            if (leftRaw === rightRaw)\n                return left;\n            var result = rightModel.copyString(null);\n            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);\n            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);\n            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);\n            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);\n            if (0 < prefix) {\n                rightModel.stringAppendSlice(result, left, 0, prefix);\n            }\n            if (prefix < rightLen - suffix) {\n                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n            }\n            if (leftLen - suffix < leftLen) {\n                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n            }\n            var value = rightModel.finalize(result);\n            if (unwrap(value) !== rightRaw)\n                throw new Error('incorrect string rebase');\n            return value;\n        }\n    }\n    return right;\n}\nfunction applyPatch(left, patch, startMeta) {\n    var model = new Model(startMeta);\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=incremental-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QztBQUNxQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtREFBbUQ7QUFDL0csbURBQW1ELG9CQUFvQjtBQUN2RSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0EsMkJBQTJCLG1EQUFZO0FBQ3ZDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1EQUFZO0FBQ3JDLHlCQUF5QixtREFBWTtBQUNyQywyQkFBMkIscURBQWM7QUFDekMsMEJBQTBCLHFEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanM/ZTZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRjaGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1wYXRjaGVyJztcbmltcG9ydCB7IHV0ZjhjaGFyU2l6ZSwgdXRmOHN0cmluZ1NpemUsIGNvbW1vblByZWZpeCwgY29tbW9uU3VmZml4IH0gZnJvbSAnLi91dGY4JztcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlbChtZXRhKSB7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgfVxuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcFdpdGhNZXRhKGRhdGEsIHRoaXMubWV0YSwgdGhpcy5tZXRhKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwV2l0aE1ldGEgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnRNZXRhLCBlbmRNZXRhKSB7XG4gICAgICAgIGlmIChlbmRNZXRhID09PSB2b2lkIDApIHsgZW5kTWV0YSA9IHRoaXMubWV0YTsgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBzdGFydE1ldGE6IHN0YXJ0TWV0YSwgZW5kTWV0YTogZW5kTWV0YSB9O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlLmRhdGEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gdGhpcy53cmFwV2l0aE1ldGEodmFsLCB2YWx1ZS5zdGFydE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUuY29udGVudCA9IHsgdHlwZTogJ29iamVjdCcsIGZpZWxkczogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHZhbHVlLmRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy53cmFwV2l0aE1ldGEoaXRlbSwgdmFsdWUuc3RhcnRNZXRhKTsgfSk7XG4gICAgICAgICAgICB2YXIgbWV0YXMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWV0YTsgfSk7XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiAnYXJyYXknLCBlbGVtZW50czogZWxlbWVudHMsIG1ldGFzOiBtZXRhcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgICAgICAgIHV0ZjhzaXplOiB1dGY4c3RyaW5nU2l6ZShzdHIpLFxuICAgICAgICAgICAgICAgIHVzZXM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0TWV0YTogdmFsdWUuc3RhcnRNZXRhLFxuICAgICAgICAgICAgICAgIGVuZE1ldGE6IHZhbHVlLmVuZE1ldGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0gdGhpcy5zdHJpbmdGcm9tUGFydHMoW3BhcnRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdGcm9tUGFydHMgPSBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgdmFyIHN0ciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgcGFydHM6IHBhcnRzXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzXzFbX2ldO1xuICAgICAgICAgICAgcGFydC51c2VzLnB1c2goc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdEdldEtleXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5jb250ZW50LmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RHZXRGaWVsZCA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iai5maWVsZHNba2V5XTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUdldEVsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5hc0FycmF5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFyci5lbGVtZW50c1tpZHhdO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4geyBjb250ZW50OiBjb250ZW50LCBzdGFydE1ldGE6IHRoaXMubWV0YSwgZW5kTWV0YTogdGhpcy5tZXRhIH07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUubWFya0NoYW5nZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh1bndyYXAodmFsdWUpKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS51cGRhdGVFbmRNZXRhID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRlbnQucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgcGFydC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBjb250ZW50LmVsZW1lbnRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gT2JqZWN0LnZhbHVlcyhjb250ZW50LmZpZWxkcyk7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmNvcHlTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhvdGhlci5wYXJ0cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgcGFydHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBmaWVsZHM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9iai5maWVsZHMsIG90aGVyLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5QXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGFyciA9IHZhbHVlID8gdGhpcy5hc0FycmF5KHZhbHVlKSA6IG51bGw7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGFyciA/IGFyci5lbGVtZW50cyA6IFtdO1xuICAgICAgICB2YXIgbWV0YXMgPSBhcnIgPyBhcnIubWV0YXMgOiBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBtZXRhczogbWV0YXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RTZXRGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmZpZWxkc1trZXldID0gdmFsdWU7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldC5maWVsZHNba2V5XTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmVsZW1lbnRzLnB1c2godmFsdWUpO1xuICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkoc291cmNlKTtcbiAgICAgICAgdmFyIHNhbWVQb3NpdGlvbiA9IGFyci5lbGVtZW50cy5sZW5ndGggPT09IGxlZnQ7XG4gICAgICAgIChfYSA9IHRhcmdldC5lbGVtZW50cykucHVzaC5hcHBseShfYSwgYXJyLmVsZW1lbnRzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIGlmIChzYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAgIChfYiA9IHRhcmdldC5tZXRhcykucHVzaC5hcHBseShfYiwgYXJyLm1ldGFzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVmdDsgaSA8IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nQXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdHIucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nQXBwZW5kUGFydCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcnQpIHtcbiAgICAgICAgdGFyZ2V0LnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIHBhcnQudXNlcy5wdXNoKHRhcmdldCk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUucmVzb2x2ZVN0cmluZ1BhcnQgPSBmdW5jdGlvbiAoc3RyLCBmcm9tLCBsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmcm9tO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICAgICAgICBpZiAobGVuID09PSBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBwZXJmZWN0IVxuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW4gPCBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHBhcnQgb2YgdGhpcyBjaHVuay4gV2Ugbm93IG5lZWQgdG8gc3BsaXQgaXQgdXAuXG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZyhwYXJ0LCBsZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiAtPSBwYXJ0LnV0ZjhzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXR0aW5nIHN0cmluZyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3BsaXRTdHJpbmcgPSBmdW5jdGlvbiAocGFydCwgaWR4KSB7XG4gICAgICAgIHZhciBsZWZ0VmFsdWU7XG4gICAgICAgIHZhciByaWdodFZhbHVlO1xuICAgICAgICB2YXIgbGVmdFNpemUgPSBpZHg7XG4gICAgICAgIHZhciByaWdodFNpemUgPSBwYXJ0LnV0ZjhzaXplIC0gbGVmdFNpemU7XG4gICAgICAgIC8vIGlkeCBpcyBoZXJlIGluIFVURi04IGluZGV4LCBub3QgY29kZXBvaW50IGluZGV4LlxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIG1pZ2h0IHRvIGFkanVzdCBmb3IgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAocGFydC51dGY4c2l6ZSAhPT0gcGFydC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBieXRlQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChpZHggPSAwOyBieXRlQ291bnQgPCBsZWZ0U2l6ZTsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHBhcnQudmFsdWUuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gNClcbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7IC8vIFN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgcmlnaHRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoaWR4KTtcbiAgICAgICAgdmFyIG5ld1BhcnQgPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmlnaHRWYWx1ZSxcbiAgICAgICAgICAgIHV0ZjhzaXplOiByaWdodFNpemUsXG4gICAgICAgICAgICB1c2VzOiBwYXJ0LnVzZXMuc2xpY2UoKSxcbiAgICAgICAgICAgIHN0YXJ0TWV0YTogcGFydC5zdGFydE1ldGEsXG4gICAgICAgICAgICBlbmRNZXRhOiBwYXJ0LmVuZE1ldGFcbiAgICAgICAgfTtcbiAgICAgICAgcGFydC52YWx1ZSA9IGxlZnRWYWx1ZTtcbiAgICAgICAgcGFydC51dGY4c2l6ZSA9IGxlZnRTaXplO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcGFydC51c2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHVzZSA9IF9hW19pXTtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IHBhcnQuXG4gICAgICAgICAgICB2YXIgaWR4XzEgPSB1c2UucGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgIGlmIChpZHhfMSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWc6IG1pc21hdGNoIGJldHdlZW4gc3RyaW5nIHBhcnRzIGFuZCB1c2UuJyk7XG4gICAgICAgICAgICB1c2UucGFydHMuc3BsaWNlKGlkeF8xICsgMSwgMCwgbmV3UGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuYXNTdHJpbmcoc291cmNlKTtcbiAgICAgICAgdmFyIGZpcnN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCAwLCBsZWZ0KTtcbiAgICAgICAgdmFyIGxhc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIGZpcnN0UGFydCwgcmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0UGFydDsgaSA8IGxhc3RQYXJ0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNb2RlbDtcbn0oKSk7XG4vLyBUdXJucyBhIG5hdGl2ZSBKYXZhU2NyaXB0IG9iamVjdCBpbnRvIGEgVmFsdWUgd2l0aCBhIGdpdmVuIG9yaWdpbi5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKGRhdGEsIG1ldGEpIHtcbiAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBzdGFydE1ldGE6IG1ldGEsIGVuZE1ldGE6IG1ldGEgfTtcbn1cbi8vIENvbnZlcnRzIGEgVmFsdWUgaW50byBhIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5kYXRhICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgY29udGVudCA9IHZhbHVlLmNvbnRlbnQ7XG4gICAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQucGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnZhbHVlOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICByZXN1bHQgPSBjb250ZW50LmVsZW1lbnRzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB1bndyYXAodmFsKTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMoY29udGVudC5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUuZGF0YSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gUmV0dXJucyB0aGUgdHlwZSBvZiBhIFZhbHVlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29udGVudClcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQudHlwZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSlcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgaWYgKHZhbHVlLmRhdGEgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5kYXRhO1xufVxuLy8gVXBkYXRlcyB0aGUgYHJpZ2h0YCB2YWx1ZSBzdWNoIHRoYXQgaXQgcmV1c2VzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgYGxlZnRgIHZhbHVlLlxuZXhwb3J0IGZ1bmN0aW9uIHJlYmFzZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIGxlZnRUeXBlID0gZ2V0VHlwZShsZWZ0KTtcbiAgICB2YXIgcmlnaHRUeXBlID0gZ2V0VHlwZShyaWdodCk7XG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpXG4gICAgICAgIHJldHVybiByaWdodDtcbiAgICB2YXIgbGVmdE1vZGVsID0gbmV3IE1vZGVsKGxlZnQuZW5kTWV0YSk7XG4gICAgdmFyIHJpZ2h0TW9kZWwgPSBuZXcgTW9kZWwocmlnaHQuZW5kTWV0YSk7XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICB2YXIgbGVmdE9iaiA9IGxlZnRNb2RlbC5hc09iamVjdChsZWZ0KTtcbiAgICAgICAgICAgIHZhciByaWdodE9iaiA9IHJpZ2h0TW9kZWwuYXNPYmplY3QocmlnaHQpO1xuICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGZpZWxkcyB3aGljaCBhcmUgaWRlbnRpY2FsIGluIGxlZnQgYW5kIHJpZ2h0LlxuICAgICAgICAgICAgdmFyIGlkZW50aWNhbEZpZWxkQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGxlZnRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMobGVmdE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciByaWdodEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhyaWdodE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhyaWdodE9iai5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHJpZ2h0VmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRWYWwgPSBsZWZ0T2JqLmZpZWxkc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0T2JqLmZpZWxkc1trZXldID0gcmViYXNlVmFsdWUobGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRPYmouZmllbGRzW2tleV0gPT09IGxlZnRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWNhbEZpZWxkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0lkZW50aWNhbCA9IGxlZnRGaWVsZENvdW50ID09PSByaWdodEZpZWxkQ291bnQgJiYgbGVmdEZpZWxkQ291bnQgPT09IGlkZW50aWNhbEZpZWxkQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gaXNJZGVudGljYWwgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICAgICAgICB2YXIgbGVmdEFyciA9IGxlZnRNb2RlbC5hc0FycmF5KGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0QXJyID0gcmlnaHRNb2RlbC5hc0FycmF5KHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChsZWZ0QXJyLmVsZW1lbnRzLmxlbmd0aCAhPT0gcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtUmViYXNlZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpZ2h0QXJyLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRBcnIuZWxlbWVudHNbaV0gPSByZWJhc2VWYWx1ZShsZWZ0QXJyLmVsZW1lbnRzW2ldLCByaWdodEFyci5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0QXJyLmVsZW1lbnRzW2ldICE9PSBsZWZ0QXJyLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVJlYmFzZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtUmViYXNlZCA9PT0gMCA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgIGlmICh1bndyYXAobGVmdCkgPT09IHVud3JhcChyaWdodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICB2YXIgbGVmdFJhdyA9IHVud3JhcChsZWZ0KTtcbiAgICAgICAgICAgIHZhciByaWdodFJhdyA9IHVud3JhcChyaWdodCk7XG4gICAgICAgICAgICBpZiAobGVmdFJhdyA9PT0gcmlnaHRSYXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmlnaHRNb2RlbC5jb3B5U3RyaW5nKG51bGwpO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNvbW1vblByZWZpeChsZWZ0UmF3LCByaWdodFJhdyk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0TGVuID0gdXRmOHN0cmluZ1NpemUocmlnaHRSYXcpO1xuICAgICAgICAgICAgdmFyIGxlZnRMZW4gPSB1dGY4c3RyaW5nU2l6ZShsZWZ0UmF3KTtcbiAgICAgICAgICAgIGlmICgwIDwgcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIDAsIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlZml4IDwgcmlnaHRMZW4gLSBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgcmlnaHQsIHByZWZpeCwgcmlnaHRMZW4gLSBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRMZW4gLSBzdWZmaXggPCBsZWZ0TGVuKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIGxlZnRMZW4gLSBzdWZmaXgsIGxlZnRMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHVud3JhcCh2YWx1ZSkgIT09IHJpZ2h0UmF3KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb3JyZWN0IHN0cmluZyByZWJhc2UnKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmlnaHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCwgc3RhcnRNZXRhKSB7XG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHN0YXJ0TWV0YSk7XG4gICAgdmFyIHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihtb2RlbCwgbGVmdCwgcGF0Y2gpO1xuICAgIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY3JlbWVudGFsLXBhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/incremental-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; },\n/* harmony export */   \"incremental\": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ \"./node_modules/mendoza/lib/esm/incremental-patcher.js\");\n/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ \"./node_modules/mendoza/lib/esm/simple-patcher.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDZjtBQUNNO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW5kZXguanM/NGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpbmNyZW1lbnRhbF8xIGZyb20gJy4vaW5jcmVtZW50YWwtcGF0Y2hlcic7XG5leHBvcnQgeyBpbmNyZW1lbnRhbF8xIGFzIGluY3JlbWVudGFsIH07XG5leHBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSAnLi9zaW1wbGUtcGF0Y2hlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/internal-patcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Patcher\": function() { return /* binding */ Patcher; }\n/* harmony export */ });\nvar OPS = [\n    'Value',\n    'Copy',\n    'Blank',\n    'ReturnIntoArray',\n    'ReturnIntoObject',\n    'ReturnIntoObjectSameKey',\n    'PushField',\n    'PushElement',\n    'PushParent',\n    'Pop',\n    'PushFieldCopy',\n    'PushFieldBlank',\n    'PushElementCopy',\n    'PushElementBlank',\n    'ReturnIntoObjectPop',\n    'ReturnIntoObjectSameKeyPop',\n    'ReturnIntoArrayPop',\n    'ObjectSetFieldValue',\n    'ObjectCopyField',\n    'ObjectDeleteField',\n    'ArrayAppendValue',\n    'ArrayAppendSlice',\n    'StringAppendString',\n    'StringAppendSlice'\n];\nvar Patcher = /** @class */ (function () {\n    function Patcher(model, root, patch) {\n        this.i = 0;\n        this.inputStack = [];\n        this.outputStack = [];\n        this.model = model;\n        this.root = root;\n        this.patch = patch;\n    }\n    Patcher.prototype.read = function () {\n        return this.patch[this.i++];\n    };\n    Patcher.prototype.process = function () {\n        this.inputStack.push({ value: this.root });\n        this.outputStack.push({ value: this.root });\n        for (; this.i < this.patch.length;) {\n            var opcode = this.read();\n            var op = OPS[opcode];\n            if (!op)\n                throw new Error(\"Unknown opcode: \" + opcode);\n            var processor = \"process\" + op;\n            this[processor].apply(this);\n        }\n        var entry = this.outputStack.pop();\n        return this.finalizeOutput(entry);\n    };\n    Patcher.prototype.inputEntry = function () {\n        return this.inputStack[this.inputStack.length - 1];\n    };\n    Patcher.prototype.inputKey = function (entry, idx) {\n        if (!entry.keys) {\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\n        }\n        return entry.keys[idx];\n    };\n    Patcher.prototype.outputEntry = function () {\n        return this.outputStack[this.outputStack.length - 1];\n    };\n    Patcher.prototype.outputArray = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyArray(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputObject = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyObject(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputString = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyString(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.finalizeOutput = function (entry) {\n        if (entry.writeValue) {\n            return this.model.finalize(entry.writeValue);\n        }\n        else {\n            return entry.value;\n        }\n    };\n    // Processors:\n    Patcher.prototype.processValue = function () {\n        var value = this.model.wrap(this.read());\n        this.outputStack.push({ value: value });\n    };\n    Patcher.prototype.processCopy = function () {\n        var input = this.inputEntry();\n        this.outputStack.push({ value: input.value });\n    };\n    Patcher.prototype.processBlank = function () {\n        this.outputStack.push({ value: null });\n    };\n    Patcher.prototype.processReturnIntoArray = function () {\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, result);\n    };\n    Patcher.prototype.processReturnIntoObject = function () {\n        var key = this.read();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        result = this.model.markChanged(result);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, key, result);\n    };\n    Patcher.prototype.processReturnIntoObjectSameKey = function () {\n        var input = this.inputEntry();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, input.key, result);\n    };\n    Patcher.prototype.processPushField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var value = this.model.objectGetField(entry.value, key);\n        this.inputStack.push({ value: value, key: key });\n    };\n    Patcher.prototype.processPushElement = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var value = this.model.arrayGetElement(entry.value, idx);\n        this.inputStack.push({ value: value });\n    };\n    Patcher.prototype.processPop = function () {\n        this.inputStack.pop();\n    };\n    Patcher.prototype.processPushFieldCopy = function () {\n        this.processPushField();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushFieldBlank = function () {\n        this.processPushField();\n        this.processBlank();\n    };\n    Patcher.prototype.processPushElementCopy = function () {\n        this.processPushElement();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushElementBlank = function () {\n        this.processPushElement();\n        this.processBlank();\n    };\n    Patcher.prototype.processReturnIntoObjectPop = function () {\n        this.processReturnIntoObject();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoArrayPop = function () {\n        this.processReturnIntoArray();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectSetFieldValue = function () {\n        this.processValue();\n        this.processReturnIntoObject();\n    };\n    Patcher.prototype.processObjectCopyField = function () {\n        this.processPushField();\n        this.processCopy();\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectDeleteField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var obj = this.outputObject();\n        this.model.objectDeleteField(obj, key);\n    };\n    Patcher.prototype.processArrayAppendValue = function () {\n        var value = this.model.wrap(this.read());\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, value);\n    };\n    Patcher.prototype.processArrayAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputArray();\n        var val = this.inputEntry().value;\n        this.model.arrayAppendSlice(str, val, left, right);\n    };\n    Patcher.prototype.processStringAppendString = function () {\n        var value = this.model.wrap(this.read());\n        var str = this.outputString();\n        this.model.stringAppendValue(str, value);\n    };\n    Patcher.prototype.processStringAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputString();\n        var val = this.inputEntry().value;\n        this.model.stringAppendSlice(str, val, left, right);\n    };\n    return Patcher;\n}());\n\n//# sourceMappingURL=internal-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQsZ0NBQWdDLGtCQUFrQjtBQUNsRCxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNrQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanM/YjYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgT1BTID0gW1xuICAgICdWYWx1ZScsXG4gICAgJ0NvcHknLFxuICAgICdCbGFuaycsXG4gICAgJ1JldHVybkludG9BcnJheScsXG4gICAgJ1JldHVybkludG9PYmplY3QnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleScsXG4gICAgJ1B1c2hGaWVsZCcsXG4gICAgJ1B1c2hFbGVtZW50JyxcbiAgICAnUHVzaFBhcmVudCcsXG4gICAgJ1BvcCcsXG4gICAgJ1B1c2hGaWVsZENvcHknLFxuICAgICdQdXNoRmllbGRCbGFuaycsXG4gICAgJ1B1c2hFbGVtZW50Q29weScsXG4gICAgJ1B1c2hFbGVtZW50QmxhbmsnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0UG9wJyxcbiAgICAnUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AnLFxuICAgICdSZXR1cm5JbnRvQXJyYXlQb3AnLFxuICAgICdPYmplY3RTZXRGaWVsZFZhbHVlJyxcbiAgICAnT2JqZWN0Q29weUZpZWxkJyxcbiAgICAnT2JqZWN0RGVsZXRlRmllbGQnLFxuICAgICdBcnJheUFwcGVuZFZhbHVlJyxcbiAgICAnQXJyYXlBcHBlbmRTbGljZScsXG4gICAgJ1N0cmluZ0FwcGVuZFN0cmluZycsXG4gICAgJ1N0cmluZ0FwcGVuZFNsaWNlJ1xuXTtcbnZhciBQYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGNoZXIobW9kZWwsIHJvb3QsIHBhdGNoKSB7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgIH1cbiAgICBQYXRjaGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIGZvciAoOyB0aGlzLmkgPCB0aGlzLnBhdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHZhciBvcCA9IE9QU1tvcGNvZGVdO1xuICAgICAgICAgICAgaWYgKCFvcClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIgKyBvcGNvZGUpO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NvciA9IFwicHJvY2Vzc1wiICsgb3A7XG4gICAgICAgICAgICB0aGlzW3Byb2Nlc3Nvcl0uYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUuaW5wdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRTdGFja1t0aGlzLmlucHV0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEtleSA9IGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7XG4gICAgICAgIGlmICghZW50cnkua2V5cykge1xuICAgICAgICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5rZXlzW2lkeF07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0U3RhY2tbdGhpcy5vdXRwdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weUFycmF5KGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlPYmplY3QoZW50cnkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5maW5hbGl6ZU91dHB1dCA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFByb2Nlc3NvcnM6XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiBpbnB1dC52YWx1ZSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IG51bGwgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwubWFya0NoYW5nZWQocmVzdWx0KTtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwgaW5wdXQua2V5LCByZXN1bHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwub2JqZWN0R2V0RmllbGQoZW50cnkudmFsdWUsIGtleSk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBrZXk6IGtleSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5hcnJheUdldEVsZW1lbnQoZW50cnkudmFsdWUsIGlkeCk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1BvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hFbGVtZW50KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0U2V0RmllbGRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzVmFsdWUoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdENvcHlGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vYmplY3REZWxldGVGaWVsZChvYmosIGtleSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgICAgICB0aGlzLm1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0Y2hlcjtcbn0oKSk7XG5leHBvcnQgeyBQYXRjaGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC1wYXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/internal-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/simple-patcher.js":
/*!********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = {\n    wrap: function (data) {\n        return data;\n    },\n    finalize: function (b) {\n        if (Array.isArray(b)) {\n            return b;\n        }\n        else {\n            return b.data;\n        }\n    },\n    markChanged: function (value) {\n        return value;\n    },\n    objectGetKeys: function (value) {\n        return Object.keys(value);\n    },\n    objectGetField: function (value, key) {\n        return value[key];\n    },\n    arrayGetElement: function (value, idx) {\n        return value[idx];\n    },\n    copyObject: function (value) {\n        var res = {\n            type: 'object',\n            data: {}\n        };\n        if (value !== null) {\n            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                res.data[key] = val;\n            }\n        }\n        return res;\n    },\n    copyArray: function (value) {\n        if (value === null)\n            return [];\n        return value.slice();\n    },\n    copyString: function (value) {\n        return {\n            type: 'string',\n            data: value === null ? '' : value\n        };\n    },\n    objectSetField: function (target, key, value) {\n        target.data[key] = value;\n    },\n    objectDeleteField: function (target, key) {\n        delete target.data[key];\n    },\n    arrayAppendValue: function (target, value) {\n        target.push(value);\n    },\n    arrayAppendSlice: function (target, source, left, right) {\n        target.push.apply(target, source.slice(left, right));\n    },\n    stringAppendSlice: function (target, source, left, right) {\n        var sourceString = source;\n        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);\n        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);\n        target.data += sourceString.slice(leftPos, rightPos);\n    },\n    stringAppendValue: function (target, value) {\n        target.data += value;\n    }\n};\n// Applies a patch on a JavaScript object.\nfunction applyPatch(left, patch) {\n    var root = left; // No need to wrap because the representation is the same.\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=simple-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QztBQUNIO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQix1REFBZ0I7QUFDdEMsdUJBQXVCLHVEQUFnQjtBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQkFBcUI7QUFDckIsc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzPzY5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0Y2hlciB9IGZyb20gJy4vaW50ZXJuYWwtcGF0Y2hlcic7XG5pbXBvcnQgeyB1dGY4cmVzb2x2ZUluZGV4IH0gZnJvbSAnLi91dGY4JztcbnZhciBNb2RlbCA9IHtcbiAgICB3cmFwOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYi5kYXRhO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXJrQ2hhbmdlZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG9iamVjdEdldEtleXM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIH0sXG4gICAgb2JqZWN0R2V0RmllbGQ6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgIH0sXG4gICAgYXJyYXlHZXRFbGVtZW50OiBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICByZXR1cm4gdmFsdWVbaWR4XTtcbiAgICB9LFxuICAgIGNvcHlPYmplY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmVzLmRhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgY29weUFycmF5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9LFxuICAgIGNvcHlTdHJpbmc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZSA9PT0gbnVsbCA/ICcnIDogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdFNldEZpZWxkOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIG9iamVjdERlbGV0ZUZpZWxkOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldC5kYXRhW2tleV07XG4gICAgfSxcbiAgICBhcnJheUFwcGVuZFZhbHVlOiBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XG4gICAgfSxcbiAgICBhcnJheUFwcGVuZFNsaWNlOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRhcmdldC5wdXNoLmFwcGx5KHRhcmdldCwgc291cmNlLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgfSxcbiAgICBzdHJpbmdBcHBlbmRTbGljZTogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgc291cmNlU3RyaW5nID0gc291cmNlO1xuICAgICAgICB2YXIgbGVmdFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCBsZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIHJpZ2h0LCBsZWZ0UG9zKTtcbiAgICAgICAgdGFyZ2V0LmRhdGEgKz0gc291cmNlU3RyaW5nLnNsaWNlKGxlZnRQb3MsIHJpZ2h0UG9zKTtcbiAgICB9LFxuICAgIHN0cmluZ0FwcGVuZFZhbHVlOiBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcbiAgICB9XG59O1xuLy8gQXBwbGllcyBhIHBhdGNoIG9uIGEgSmF2YVNjcmlwdCBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCkge1xuICAgIHZhciByb290ID0gbGVmdDsgLy8gTm8gbmVlZCB0byB3cmFwIGJlY2F1c2UgdGhlIHJlcHJlc2VudGF0aW9uIGlzIHRoZSBzYW1lLlxuICAgIHZhciBwYXRjaGVyID0gbmV3IFBhdGNoZXIoTW9kZWwsIHJvb3QsIHBhdGNoKTtcbiAgICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGUtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/simple-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/utf8.js":
/*!**********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/utf8.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"commonPrefix\": function() { return /* binding */ commonPrefix; },\n/* harmony export */   \"commonSuffix\": function() { return /* binding */ commonSuffix; },\n/* harmony export */   \"utf8charSize\": function() { return /* binding */ utf8charSize; },\n/* harmony export */   \"utf8resolveIndex\": function() { return /* binding */ utf8resolveIndex; },\n/* harmony export */   \"utf8stringSize\": function() { return /* binding */ utf8stringSize; }\n/* harmony export */ });\nfunction utf8charSize(code) {\n    if (code >> 16) {\n        return 4;\n    }\n    else if (code >> 11) {\n        return 3;\n    }\n    else if (code >> 7) {\n        return 2;\n    }\n    else {\n        return 1;\n    }\n}\nfunction utf8stringSize(str) {\n    var b = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.codePointAt(i);\n        var size = utf8charSize(code);\n        if (size == 4)\n            i++;\n        b += size;\n    }\n    return b;\n}\n/** Converts an UTF-8 byte index into a UCS-2 index. */\nfunction utf8resolveIndex(str, idx, start) {\n    if (start === void 0) { start = 0; }\n    var byteCount = start;\n    var ucsIdx = 0;\n    for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n        var code = str.codePointAt(ucsIdx);\n        var size = utf8charSize(code);\n        if (size === 4)\n            ucsIdx++; // Surrogate pair.\n        byteCount += size;\n    }\n    return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n    var len = Math.min(str.length, str2.length);\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(i);\n        var bPoint = str2.codePointAt(i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nfunction commonSuffix(str, str2, prefix) {\n    if (prefix === void 0) { prefix = 0; }\n    var len = Math.min(str.length, str2.length) - prefix;\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(str.length - 1 - i);\n        var bPoint = str2.codePointAt(str2.length - 1 - i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanM/ZWM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcbiAgICBpZiAoY29kZSA+PiAxNikge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA+PiAxMSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA+PiA3KSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhzdHJpbmdTaXplKHN0cikge1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgICAgIGlmIChzaXplID09IDQpXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGIgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG4vKiogQ29udmVydHMgYW4gVVRGLTggYnl0ZSBpbmRleCBpbnRvIGEgVUNTLTIgaW5kZXguICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOHJlc29sdmVJbmRleChzdHIsIGlkeCwgc3RhcnQpIHtcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICB2YXIgYnl0ZUNvdW50ID0gc3RhcnQ7XG4gICAgdmFyIHVjc0lkeCA9IDA7XG4gICAgZm9yICh1Y3NJZHggPSBzdGFydDsgYnl0ZUNvdW50IDwgaWR4OyB1Y3NJZHgrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jb2RlUG9pbnRBdCh1Y3NJZHgpO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgaWYgKHNpemUgPT09IDQpXG4gICAgICAgICAgICB1Y3NJZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gdWNzSWR4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpO1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgdmFyIGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgdmFyIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgICAgICBiICs9IHNpemU7XG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25TdWZmaXgoc3RyLCBzdHIyLCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHsgcHJlZml4ID0gMDsgfVxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCkgLSBwcmVmaXg7XG4gICAgdmFyIGIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KHN0ci5sZW5ndGggLSAxIC0gaSk7XG4gICAgICAgIHZhciBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KHN0cjIubGVuZ3RoIC0gMSAtIGkpO1xuICAgICAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICAgICAgYiArPSBzaXplO1xuICAgICAgICBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/utf8.js\n"));

/***/ }),

/***/ "./node_modules/@sanity/groq-store/dist/browser/groq-store.modern.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@sanity/groq-store/dist/browser/groq-store.modern.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"groq\": function() { return /* reexport default export from named module */ groq__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   \"groqStore\": function() { return /* binding */ w; }\n/* harmony export */ });\n/* harmony import */ var groq__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! groq */ \"./node_modules/groq/lib/groq.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var throttle_debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! throttle-debounce */ \"./node_modules/throttle-debounce/esm/index.js\");\n/* harmony import */ var groq_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! groq-js */ \"./node_modules/groq-js/dist/1.esm.mjs\");\n/* harmony import */ var mendoza__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mendoza */ \"./node_modules/mendoza/lib/esm/index.js\");\nfunction s(){return s=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},s.apply(this,arguments)}const a=(e,t,r)=>{(e=>\"undefined\"!=typeof window&&e.addEventListener===window.EventSource.prototype.addEventListener)(e)&&e.addEventListener(t,r,!1),e.addEventListener(t,r)};function c(e,t,r){const{projectId:n,dataset:o,token:i}=t,s=new e(`https://${n}.api.sanity.io/v1/data/listen/${o}?query=*&effectFormat=mendoza`,{withCredentials:!0,headers:i?{Authorization:`Bearer ${i}`}:void 0});var c;return a(s,\"welcome\",r.open),a(s,\"mutation\",(c=r.next,e=>{let t;try{t=JSON.parse(e.data)}catch(e){return}c(t)})),a(s,\"channelError\",e=>{let t;s.close();try{t=JSON.parse(e.data)}catch(e){return void r.error(new Error(\"Unknown error parsing listener message\"))}r.error(new Error(t.message||t.error||`Listener returned HTTP ${t.statusCode}`))}),a(s,\"error\",e=>{const t=\"undefined\"!=typeof window&&window.location.origin,n=t?`, and that the CORS-origin (${t}) is allowed`:\"\",o=function(e){return\"object\"==typeof e&&null!==e&&\"message\"in e}(e)?` (${e.message})`:\"\";r.error(new Error(`Error establishing listener - check that the project ID and dataset are correct${n}${o}`))}),{unsubscribe:()=>Promise.resolve(s.close())}}function u(e){return e._id.startsWith(\"drafts.\")?e._id.slice(7):e._id}function d(e,t){const r=s({},e);return delete r._rev,(0,mendoza__WEBPACK_IMPORTED_MODULE_3__.applyPatch)(r,t)}function l(){return Promise.resolve()}let f,p=e=>e;const h=async function({projectId:e,dataset:t,token:r,documentLimit:n,includeTypes:o=[]}){const i=`https://${e}.api.sanity.io/v1/data/export/${t}?${o.length>0?new URLSearchParams({types:null==o?void 0:o.join(\",\")}):\"\"}`,s=r?{Authorization:`Bearer ${r}`}:void 0,a=await fetch(i,{credentials:\"include\",headers:s});if(200!==a.status)throw new Error(`Error streaming dataset: ${c=await a.json(),\"object\"==typeof c&&\"error\"in c&&\"message\"in c?c.message||c.error:\"<unknown error>\"}`);var c;const u=function(e){if(!e)throw new Error(\"Failed to read body from response\");let t,r=!1;function n(){r=!0,t&&t.cancel()}return new ReadableStream({start(o){t=e.getReader();const i=new TextDecoder;let s=\"\";t.read().then(async function e(a){if(a.done){if(r)return;return s=s.trim(),0===s.length||o.enqueue(JSON.parse(s)),void o.close()}s+=i.decode(a.value,{stream:!0});const c=s.split(\"\\n\");for(let e=0;e<c.length-1;++e){const t=c[e].trim();if(0!==t.length)try{o.enqueue(JSON.parse(t))}catch(e){return o.error(e),void n()}}if(s=c[c.length-1],t)try{e(await t.read())}catch(e){o.error(e)}}).catch(e=>o.error(e))},cancel:n})}(a.body),d=u.getReader(),l=[];let f,p;do{if(f=await d.read(),p=f.value,m(p))throw new Error(`Error streaming dataset: ${p.error}`);if(p&&!p._id.startsWith(\"_.\")&&l.push(p),n&&l.length>n)throw d.cancel(\"Reached document limit\"),new Error(`Error streaming dataset: Reached limit of ${n} documents. Try using the includeTypes option to reduce the amount of documents, or increase the limit.`)}while(!f.done);return l};function m(e){return!!e&&\"error\"in e&&\"object\"==typeof e.error&&null!==e.error&&\"description\"in e.error&&\"string\"==typeof e.error.description&&!(\"_id\"in e)}function w(i){var a;!function(){const e=[\"EventSource\",\"ReadableStream\",\"fetch\"].filter(e=>!(e in window));if(e.length>0)throw new Error(`Browser not supported. Missing browser APIs: ${e.join(\", \")}`)}();const m=null!=(a=i.EventSource)?a:window.EventSource;if(i.token){if(!i.EventSource)throw new Error(\"When the `token` option is used the `EventSource` option must also be provided.\");if(i.EventSource===window.EventSource)throw new Error(\"When the `token` option is used the `EventSource` option must also be provided. EventSource cannot be `window.EventSource`, as it does not support passing a token.\")}return function(i,a){let h=[];const m=(0,throttle_debounce__WEBPACK_IMPORTED_MODULE_2__.throttle)(i.subscriptionThrottleMs||50,function(){w.forEach(E)}),w=[];let v;async function g(){v||(v=function(e,t,{getDocuments:r,EventSource:n}){const{projectId:o,dataset:i,listen:a,overlayDrafts:f,documentLimit:p,token:h,includeTypes:m}=e;if(!a)return{unsubscribe:l,loaded:r({projectId:o,dataset:i,documentLimit:p,token:h,includeTypes:m}).then(_).then(l)};const w=new Map;let v;const g=[];let y,E;const b=new Promise((e,t)=>{y=e,E=t});let S,$,j;return{unsubscribe:c(n,e,{next:function(e){v?(function(e){if(!e.effects||e.documentId.startsWith(\"_.\"))return;const t=w.get(e.documentId)||null;!function(e,t){const r=w.get(e),n=v||[],o=r?n.indexOf(r):-1;-1===o&&t?(n.push(t),w.set(e,t)):t?(n.splice(o,1,t),w.set(e,t)):(n.splice(o,1),w.delete(e))}(e.documentId,d(t,e.effects.apply))}(e),function(e,t){clearTimeout(j),$!==t.transactionId&&S?(_(S),$=void 0):($=t.transactionId,S=e.slice()),j=setTimeout(_,25,e.slice())}(v,e)):g.push(e)},open:async function(){const e=await r({projectId:o,dataset:i,documentLimit:p,token:h,includeTypes:m});v=function(e,t){const r=new Map;return t.forEach(e=>{const t=r.get(e.documentId)||[];t.push(e),r.set(e.documentId,t)}),r.forEach((t,r)=>{const n=e.find(e=>e._id===r);if(!n)return void console.warn(\"Received mutation for missing document %s\",r);let o=!1,i=n;t.forEach(e=>{o=o||e.previousRev===n._rev,o&&e.effects&&(i=d(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}),e}(e,g),v.forEach(e=>w.set(e._id,e)),_(v),y()},error:e=>E(e)}).unsubscribe,loaded:b};function _(e){S=void 0,j=void 0,$=void 0,t(f?function(e){const t=new Map;return e.forEach(e=>{const r=t.get(u(e));e._id.startsWith(\"drafts.\")?t.set(u(e),function(e){return s({},e,{_id:u(e)})}(e)):r||t.set(e._id,e)}),Array.from(t.values())}(e):e)}}(i,e=>{h=e,m()},a)),await v.loaded}async function y(e,t){await g();const r=(0,groq_js__WEBPACK_IMPORTED_MODULE_4__.parse)(e,{params:t});return(await (0,groq_js__WEBPACK_IMPORTED_MODULE_4__.evaluate)(r,{dataset:h,params:t})).get()}function E(e){return y(e.query,e.params).then(r=>{\"previousResult\"in e&&fast_deep_equal__WEBPACK_IMPORTED_MODULE_1__(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(t=>{e.callback(t)})}return{query:y,getDocument:async function(t){return await g(),y(groq__WEBPACK_IMPORTED_MODULE_0__(f||(f=p`*[_id == $id][0]`)),{id:t})},getDocuments:async function(e){return await g(),y(`[${e.map(e=>`*[_id == \"${e}\"][0]`).join(\",\\n\")}]`)},subscribe:function(e,t,r){if(!i.listen)throw new Error(\"Cannot use `subscribe()` without `listen: true`\");const n={query:e,params:t,callback:r};w.push(n);let o=!1;return E(n),{unsubscribe:()=>(o||(o=!0,w.splice(w.indexOf(n),1)),Promise.resolve())}},close:function(){return m.cancel(),v?v.unsubscribe():Promise.resolve()}}}(i,{EventSource:m,getDocuments:h})}\n//# sourceMappingURL=groq-store.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ncm9xLXN0b3JlL2Rpc3QvYnJvd3Nlci9ncm9xLXN0b3JlLm1vZGVybi5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxTixhQUFhLHdEQUF3RCxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixzRUFBc0UsU0FBUyx5QkFBeUIsa0JBQWtCLDRKQUE0SixrQkFBa0IsTUFBTSw4QkFBOEIsc0JBQXNCLEVBQUUsZ0NBQWdDLEVBQUUsZ0NBQWdDLDhCQUE4Qix3QkFBd0IsRUFBRSxFQUFFLFFBQVEsRUFBRSxNQUFNLDBEQUEwRCxNQUFNLElBQUkscUJBQXFCLFNBQVMsT0FBTyxLQUFLLDBCQUEwQixNQUFNLFVBQVUsSUFBSSxxQkFBcUIsU0FBUyx5RUFBeUUsZ0VBQWdFLGFBQWEsSUFBSSxrQkFBa0IsOEZBQThGLEVBQUUsK0JBQStCLGtEQUFrRCxTQUFTLFVBQVUsTUFBTSxvR0FBb0csRUFBRSxFQUFFLEVBQUUsSUFBSSxHQUFHLDRDQUE0QyxjQUFjLHdEQUF3RCxnQkFBZ0IsWUFBWSxJQUFJLHFCQUFxQixtREFBQyxNQUFNLGFBQWEseUJBQXlCLGFBQWEsd0JBQXdCLGdFQUFnRSxFQUFFLG1CQUFtQixFQUFFLGdDQUFnQyxFQUFFLEdBQUcsZ0NBQWdDLGlDQUFpQyxLQUFLLE9BQU8sd0JBQXdCLEVBQUUsRUFBRSx5QkFBeUIsZ0NBQWdDLEVBQUUsOERBQThELHFHQUFxRyxHQUFHLE1BQU0sb0JBQW9CLDJEQUEyRCxXQUFXLGFBQWEsbUJBQW1CLDJCQUEyQixTQUFTLGdCQUFnQix3QkFBd0IsU0FBUyxrQ0FBa0MsV0FBVyxZQUFZLHdFQUF3RSxxQkFBcUIsVUFBVSxFQUFFLHNCQUFzQixZQUFZLGFBQWEsS0FBSyxvQkFBb0Isb0JBQW9CLHlCQUF5QixTQUFTLDRCQUE0Qix5QkFBeUIsa0JBQWtCLFNBQVMsWUFBWSx1QkFBdUIsVUFBVSxFQUFFLDhCQUE4QixRQUFRLEdBQUcsK0VBQStFLFFBQVEsR0FBRyx1SkFBdUosR0FBRyx5R0FBeUcsZUFBZSxVQUFVLGNBQWMsOElBQThJLGNBQWMsTUFBTSxZQUFZLDJFQUEyRSw4RUFBOEUsYUFBYSxHQUFHLEdBQUcscURBQXFELFlBQVkscUhBQXFILDZOQUE2TixxQkFBcUIsU0FBUyxRQUFRLDJEQUFDLHlDQUF5QyxhQUFhLE9BQU8sTUFBTSxtQkFBbUIsb0JBQW9CLDZCQUE2QixFQUFFLE1BQU0sc0ZBQXNGLEdBQUcsYUFBYSx3QkFBd0IsNkRBQTZELG1CQUFtQixnQkFBZ0IsTUFBTSxXQUFXLFFBQVEsNEJBQTRCLFFBQVEsRUFBRSxVQUFVLE9BQU8sbUJBQW1CLGlCQUFpQixlQUFlLG9EQUFvRCxrQ0FBa0MsZUFBZSw2Q0FBNkMsNEZBQTRGLG9DQUFvQyxrQkFBa0Isb0hBQW9ILGlCQUFpQix1QkFBdUIsaUJBQWlCLDZEQUE2RCxFQUFFLGdCQUFnQixnQkFBZ0IscUJBQXFCLGdDQUFnQyxnQ0FBZ0Msb0JBQW9CLDZCQUE2Qiw4RUFBOEUsYUFBYSxjQUFjLG1FQUFtRSw2QkFBNkIsSUFBSSw0Q0FBNEMsZUFBZSx3QkFBd0IsY0FBYywyQ0FBMkMsZ0JBQWdCLHFCQUFxQixvQkFBb0IsbURBQW1ELFdBQVcsSUFBSSxTQUFTLEVBQUUsdUJBQXVCLHlCQUF5QixRQUFRLE9BQU8sUUFBUSxvQkFBb0Isc0JBQXNCLFVBQVUsUUFBUSw4Q0FBQyxJQUFJLFNBQVMsRUFBRSxhQUFhLGlEQUFDLElBQUksbUJBQW1CLFNBQVMsY0FBYyxvQ0FBb0Msc0JBQXNCLDRDQUFDLGdFQUFnRSxZQUFZLGNBQWMsRUFBRSxPQUFPLHNDQUFzQyxtQkFBbUIsaUNBQUMsOEJBQThCLEtBQUssRUFBRSxnQ0FBZ0MsdUJBQXVCLHNCQUFzQixFQUFFLG9CQUFvQixJQUFJLDJCQUEyQixnRkFBZ0YsU0FBUyw2QkFBNkIsVUFBVSxTQUFTLGFBQWEsd0VBQXdFLGtCQUFrQix3REFBd0QsSUFBSSw2QkFBNkIsRUFBeUI7QUFDM2dOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2dyb3Etc3RvcmUvZGlzdC9icm93c2VyL2dyb3Etc3RvcmUubW9kZXJuLm1qcz80NGEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlIGZyb21cImdyb3FcIjtleHBvcnR7ZGVmYXVsdCBhcyBncm9xfWZyb21cImdyb3FcIjtpbXBvcnQgdCBmcm9tXCJmYXN0LWRlZXAtZXF1YWxcIjtpbXBvcnR7dGhyb3R0bGUgYXMgcn1mcm9tXCJ0aHJvdHRsZS1kZWJvdW5jZVwiO2ltcG9ydHtwYXJzZSBhcyBuLGV2YWx1YXRlIGFzIG99ZnJvbVwiZ3JvcS1qc1wiO2ltcG9ydHthcHBseVBhdGNoIGFzIGl9ZnJvbVwibWVuZG96YVwiO2Z1bmN0aW9uIHMoKXtyZXR1cm4gcz1PYmplY3QuYXNzaWduP09iamVjdC5hc3NpZ24uYmluZCgpOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XTtmb3IodmFyIG4gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKSYmKGVbbl09cltuXSl9cmV0dXJuIGV9LHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbnN0IGE9KGUsdCxyKT0+eyhlPT5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZlLmFkZEV2ZW50TGlzdGVuZXI9PT13aW5kb3cuRXZlbnRTb3VyY2UucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIpKGUpJiZlLmFkZEV2ZW50TGlzdGVuZXIodCxyLCExKSxlLmFkZEV2ZW50TGlzdGVuZXIodCxyKX07ZnVuY3Rpb24gYyhlLHQscil7Y29uc3R7cHJvamVjdElkOm4sZGF0YXNldDpvLHRva2VuOml9PXQscz1uZXcgZShgaHR0cHM6Ly8ke259LmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9saXN0ZW4vJHtvfT9xdWVyeT0qJmVmZmVjdEZvcm1hdD1tZW5kb3phYCx7d2l0aENyZWRlbnRpYWxzOiEwLGhlYWRlcnM6aT97QXV0aG9yaXphdGlvbjpgQmVhcmVyICR7aX1gfTp2b2lkIDB9KTt2YXIgYztyZXR1cm4gYShzLFwid2VsY29tZVwiLHIub3BlbiksYShzLFwibXV0YXRpb25cIiwoYz1yLm5leHQsZT0+e2xldCB0O3RyeXt0PUpTT04ucGFyc2UoZS5kYXRhKX1jYXRjaChlKXtyZXR1cm59Yyh0KX0pKSxhKHMsXCJjaGFubmVsRXJyb3JcIixlPT57bGV0IHQ7cy5jbG9zZSgpO3RyeXt0PUpTT04ucGFyc2UoZS5kYXRhKX1jYXRjaChlKXtyZXR1cm4gdm9pZCByLmVycm9yKG5ldyBFcnJvcihcIlVua25vd24gZXJyb3IgcGFyc2luZyBsaXN0ZW5lciBtZXNzYWdlXCIpKX1yLmVycm9yKG5ldyBFcnJvcih0Lm1lc3NhZ2V8fHQuZXJyb3J8fGBMaXN0ZW5lciByZXR1cm5lZCBIVFRQICR7dC5zdGF0dXNDb2RlfWApKX0pLGEocyxcImVycm9yXCIsZT0+e2NvbnN0IHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LmxvY2F0aW9uLm9yaWdpbixuPXQ/YCwgYW5kIHRoYXQgdGhlIENPUlMtb3JpZ2luICgke3R9KSBpcyBhbGxvd2VkYDpcIlwiLG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm1lc3NhZ2VcImluIGV9KGUpP2AgKCR7ZS5tZXNzYWdlfSlgOlwiXCI7ci5lcnJvcihuZXcgRXJyb3IoYEVycm9yIGVzdGFibGlzaGluZyBsaXN0ZW5lciAtIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgSUQgYW5kIGRhdGFzZXQgYXJlIGNvcnJlY3Qke259JHtvfWApKX0pLHt1bnN1YnNjcmliZTooKT0+UHJvbWlzZS5yZXNvbHZlKHMuY2xvc2UoKSl9fWZ1bmN0aW9uIHUoZSl7cmV0dXJuIGUuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP2UuX2lkLnNsaWNlKDcpOmUuX2lkfWZ1bmN0aW9uIGQoZSx0KXtjb25zdCByPXMoe30sZSk7cmV0dXJuIGRlbGV0ZSByLl9yZXYsaShyLHQpfWZ1bmN0aW9uIGwoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9bGV0IGYscD1lPT5lO2NvbnN0IGg9YXN5bmMgZnVuY3Rpb24oe3Byb2plY3RJZDplLGRhdGFzZXQ6dCx0b2tlbjpyLGRvY3VtZW50TGltaXQ6bixpbmNsdWRlVHlwZXM6bz1bXX0pe2NvbnN0IGk9YGh0dHBzOi8vJHtlfS5hcGkuc2FuaXR5LmlvL3YxL2RhdGEvZXhwb3J0LyR7dH0/JHtvLmxlbmd0aD4wP25ldyBVUkxTZWFyY2hQYXJhbXMoe3R5cGVzOm51bGw9PW8/dm9pZCAwOm8uam9pbihcIixcIil9KTpcIlwifWAscz1yP3tBdXRob3JpemF0aW9uOmBCZWFyZXIgJHtyfWB9OnZvaWQgMCxhPWF3YWl0IGZldGNoKGkse2NyZWRlbnRpYWxzOlwiaW5jbHVkZVwiLGhlYWRlcnM6c30pO2lmKDIwMCE9PWEuc3RhdHVzKXRocm93IG5ldyBFcnJvcihgRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6ICR7Yz1hd2FpdCBhLmpzb24oKSxcIm9iamVjdFwiPT10eXBlb2YgYyYmXCJlcnJvclwiaW4gYyYmXCJtZXNzYWdlXCJpbiBjP2MubWVzc2FnZXx8Yy5lcnJvcjpcIjx1bmtub3duIGVycm9yPlwifWApO3ZhciBjO2NvbnN0IHU9ZnVuY3Rpb24oZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJlYWQgYm9keSBmcm9tIHJlc3BvbnNlXCIpO2xldCB0LHI9ITE7ZnVuY3Rpb24gbigpe3I9ITAsdCYmdC5jYW5jZWwoKX1yZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChvKXt0PWUuZ2V0UmVhZGVyKCk7Y29uc3QgaT1uZXcgVGV4dERlY29kZXI7bGV0IHM9XCJcIjt0LnJlYWQoKS50aGVuKGFzeW5jIGZ1bmN0aW9uIGUoYSl7aWYoYS5kb25lKXtpZihyKXJldHVybjtyZXR1cm4gcz1zLnRyaW0oKSwwPT09cy5sZW5ndGh8fG8uZW5xdWV1ZShKU09OLnBhcnNlKHMpKSx2b2lkIG8uY2xvc2UoKX1zKz1pLmRlY29kZShhLnZhbHVlLHtzdHJlYW06ITB9KTtjb25zdCBjPXMuc3BsaXQoXCJcXG5cIik7Zm9yKGxldCBlPTA7ZTxjLmxlbmd0aC0xOysrZSl7Y29uc3QgdD1jW2VdLnRyaW0oKTtpZigwIT09dC5sZW5ndGgpdHJ5e28uZW5xdWV1ZShKU09OLnBhcnNlKHQpKX1jYXRjaChlKXtyZXR1cm4gby5lcnJvcihlKSx2b2lkIG4oKX19aWYocz1jW2MubGVuZ3RoLTFdLHQpdHJ5e2UoYXdhaXQgdC5yZWFkKCkpfWNhdGNoKGUpe28uZXJyb3IoZSl9fSkuY2F0Y2goZT0+by5lcnJvcihlKSl9LGNhbmNlbDpufSl9KGEuYm9keSksZD11LmdldFJlYWRlcigpLGw9W107bGV0IGYscDtkb3tpZihmPWF3YWl0IGQucmVhZCgpLHA9Zi52YWx1ZSxtKHApKXRocm93IG5ldyBFcnJvcihgRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6ICR7cC5lcnJvcn1gKTtpZihwJiYhcC5faWQuc3RhcnRzV2l0aChcIl8uXCIpJiZsLnB1c2gocCksbiYmbC5sZW5ndGg+bil0aHJvdyBkLmNhbmNlbChcIlJlYWNoZWQgZG9jdW1lbnQgbGltaXRcIiksbmV3IEVycm9yKGBFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogUmVhY2hlZCBsaW1pdCBvZiAke259IGRvY3VtZW50cy4gVHJ5IHVzaW5nIHRoZSBpbmNsdWRlVHlwZXMgb3B0aW9uIHRvIHJlZHVjZSB0aGUgYW1vdW50IG9mIGRvY3VtZW50cywgb3IgaW5jcmVhc2UgdGhlIGxpbWl0LmApfXdoaWxlKCFmLmRvbmUpO3JldHVybiBsfTtmdW5jdGlvbiBtKGUpe3JldHVybiEhZSYmXCJlcnJvclwiaW4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUuZXJyb3ImJm51bGwhPT1lLmVycm9yJiZcImRlc2NyaXB0aW9uXCJpbiBlLmVycm9yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5lcnJvci5kZXNjcmlwdGlvbiYmIShcIl9pZFwiaW4gZSl9ZnVuY3Rpb24gdyhpKXt2YXIgYTshZnVuY3Rpb24oKXtjb25zdCBlPVtcIkV2ZW50U291cmNlXCIsXCJSZWFkYWJsZVN0cmVhbVwiLFwiZmV0Y2hcIl0uZmlsdGVyKGU9PiEoZSBpbiB3aW5kb3cpKTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihgQnJvd3NlciBub3Qgc3VwcG9ydGVkLiBNaXNzaW5nIGJyb3dzZXIgQVBJczogJHtlLmpvaW4oXCIsIFwiKX1gKX0oKTtjb25zdCBtPW51bGwhPShhPWkuRXZlbnRTb3VyY2UpP2E6d2luZG93LkV2ZW50U291cmNlO2lmKGkudG9rZW4pe2lmKCFpLkV2ZW50U291cmNlKXRocm93IG5ldyBFcnJvcihcIldoZW4gdGhlIGB0b2tlbmAgb3B0aW9uIGlzIHVzZWQgdGhlIGBFdmVudFNvdXJjZWAgb3B0aW9uIG11c3QgYWxzbyBiZSBwcm92aWRlZC5cIik7aWYoaS5FdmVudFNvdXJjZT09PXdpbmRvdy5FdmVudFNvdXJjZSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHRoZSBgdG9rZW5gIG9wdGlvbiBpcyB1c2VkIHRoZSBgRXZlbnRTb3VyY2VgIG9wdGlvbiBtdXN0IGFsc28gYmUgcHJvdmlkZWQuIEV2ZW50U291cmNlIGNhbm5vdCBiZSBgd2luZG93LkV2ZW50U291cmNlYCwgYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBwYXNzaW5nIGEgdG9rZW4uXCIpfXJldHVybiBmdW5jdGlvbihpLGEpe2xldCBoPVtdO2NvbnN0IG09cihpLnN1YnNjcmlwdGlvblRocm90dGxlTXN8fDUwLGZ1bmN0aW9uKCl7dy5mb3JFYWNoKEUpfSksdz1bXTtsZXQgdjthc3luYyBmdW5jdGlvbiBnKCl7dnx8KHY9ZnVuY3Rpb24oZSx0LHtnZXREb2N1bWVudHM6cixFdmVudFNvdXJjZTpufSl7Y29uc3R7cHJvamVjdElkOm8sZGF0YXNldDppLGxpc3RlbjphLG92ZXJsYXlEcmFmdHM6Zixkb2N1bWVudExpbWl0OnAsdG9rZW46aCxpbmNsdWRlVHlwZXM6bX09ZTtpZighYSlyZXR1cm57dW5zdWJzY3JpYmU6bCxsb2FkZWQ6cih7cHJvamVjdElkOm8sZGF0YXNldDppLGRvY3VtZW50TGltaXQ6cCx0b2tlbjpoLGluY2x1ZGVUeXBlczptfSkudGhlbihfKS50aGVuKGwpfTtjb25zdCB3PW5ldyBNYXA7bGV0IHY7Y29uc3QgZz1bXTtsZXQgeSxFO2NvbnN0IGI9bmV3IFByb21pc2UoKGUsdCk9Pnt5PWUsRT10fSk7bGV0IFMsJCxqO3JldHVybnt1bnN1YnNjcmliZTpjKG4sZSx7bmV4dDpmdW5jdGlvbihlKXt2PyhmdW5jdGlvbihlKXtpZighZS5lZmZlY3RzfHxlLmRvY3VtZW50SWQuc3RhcnRzV2l0aChcIl8uXCIpKXJldHVybjtjb25zdCB0PXcuZ2V0KGUuZG9jdW1lbnRJZCl8fG51bGw7IWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj13LmdldChlKSxuPXZ8fFtdLG89cj9uLmluZGV4T2Yocik6LTE7LTE9PT1vJiZ0PyhuLnB1c2godCksdy5zZXQoZSx0KSk6dD8obi5zcGxpY2UobywxLHQpLHcuc2V0KGUsdCkpOihuLnNwbGljZShvLDEpLHcuZGVsZXRlKGUpKX0oZS5kb2N1bWVudElkLGQodCxlLmVmZmVjdHMuYXBwbHkpKX0oZSksZnVuY3Rpb24oZSx0KXtjbGVhclRpbWVvdXQoaiksJCE9PXQudHJhbnNhY3Rpb25JZCYmUz8oXyhTKSwkPXZvaWQgMCk6KCQ9dC50cmFuc2FjdGlvbklkLFM9ZS5zbGljZSgpKSxqPXNldFRpbWVvdXQoXywyNSxlLnNsaWNlKCkpfSh2LGUpKTpnLnB1c2goZSl9LG9wZW46YXN5bmMgZnVuY3Rpb24oKXtjb25zdCBlPWF3YWl0IHIoe3Byb2plY3RJZDpvLGRhdGFzZXQ6aSxkb2N1bWVudExpbWl0OnAsdG9rZW46aCxpbmNsdWRlVHlwZXM6bX0pO3Y9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW5ldyBNYXA7cmV0dXJuIHQuZm9yRWFjaChlPT57Y29uc3QgdD1yLmdldChlLmRvY3VtZW50SWQpfHxbXTt0LnB1c2goZSksci5zZXQoZS5kb2N1bWVudElkLHQpfSksci5mb3JFYWNoKCh0LHIpPT57Y29uc3Qgbj1lLmZpbmQoZT0+ZS5faWQ9PT1yKTtpZighbilyZXR1cm4gdm9pZCBjb25zb2xlLndhcm4oXCJSZWNlaXZlZCBtdXRhdGlvbiBmb3IgbWlzc2luZyBkb2N1bWVudCAlc1wiLHIpO2xldCBvPSExLGk9bjt0LmZvckVhY2goZT0+e289b3x8ZS5wcmV2aW91c1Jldj09PW4uX3JldixvJiZlLmVmZmVjdHMmJihpPWQoaSxlLmVmZmVjdHMuYXBwbHkpKX0pLGUuc3BsaWNlKGUuaW5kZXhPZihuKSwxLGkpfSksZX0oZSxnKSx2LmZvckVhY2goZT0+dy5zZXQoZS5faWQsZSkpLF8odikseSgpfSxlcnJvcjplPT5FKGUpfSkudW5zdWJzY3JpYmUsbG9hZGVkOmJ9O2Z1bmN0aW9uIF8oZSl7Uz12b2lkIDAsaj12b2lkIDAsJD12b2lkIDAsdChmP2Z1bmN0aW9uKGUpe2NvbnN0IHQ9bmV3IE1hcDtyZXR1cm4gZS5mb3JFYWNoKGU9Pntjb25zdCByPXQuZ2V0KHUoZSkpO2UuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP3Quc2V0KHUoZSksZnVuY3Rpb24oZSl7cmV0dXJuIHMoe30sZSx7X2lkOnUoZSl9KX0oZSkpOnJ8fHQuc2V0KGUuX2lkLGUpfSksQXJyYXkuZnJvbSh0LnZhbHVlcygpKX0oZSk6ZSl9fShpLGU9PntoPWUsbSgpfSxhKSksYXdhaXQgdi5sb2FkZWR9YXN5bmMgZnVuY3Rpb24geShlLHQpe2F3YWl0IGcoKTtjb25zdCByPW4oZSx7cGFyYW1zOnR9KTtyZXR1cm4oYXdhaXQgbyhyLHtkYXRhc2V0OmgscGFyYW1zOnR9KSkuZ2V0KCl9ZnVuY3Rpb24gRShlKXtyZXR1cm4geShlLnF1ZXJ5LGUucGFyYW1zKS50aGVuKHI9PntcInByZXZpb3VzUmVzdWx0XCJpbiBlJiZ0KGUucHJldmlvdXNSZXN1bHQscil8fChlLnByZXZpb3VzUmVzdWx0PXIsZS5jYWxsYmFjayh2b2lkIDAscikpfSkuY2F0Y2godD0+e2UuY2FsbGJhY2sodCl9KX1yZXR1cm57cXVlcnk6eSxnZXREb2N1bWVudDphc3luYyBmdW5jdGlvbih0KXtyZXR1cm4gYXdhaXQgZygpLHkoZShmfHwoZj1wYCpbX2lkID09ICRpZF1bMF1gKSkse2lkOnR9KX0sZ2V0RG9jdW1lbnRzOmFzeW5jIGZ1bmN0aW9uKGUpe3JldHVybiBhd2FpdCBnKCkseShgWyR7ZS5tYXAoZT0+YCpbX2lkID09IFwiJHtlfVwiXVswXWApLmpvaW4oXCIsXFxuXCIpfV1gKX0sc3Vic2NyaWJlOmZ1bmN0aW9uKGUsdCxyKXtpZighaS5saXN0ZW4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBgc3Vic2NyaWJlKClgIHdpdGhvdXQgYGxpc3RlbjogdHJ1ZWBcIik7Y29uc3Qgbj17cXVlcnk6ZSxwYXJhbXM6dCxjYWxsYmFjazpyfTt3LnB1c2gobik7bGV0IG89ITE7cmV0dXJuIEUobikse3Vuc3Vic2NyaWJlOigpPT4ob3x8KG89ITAsdy5zcGxpY2Uody5pbmRleE9mKG4pLDEpKSxQcm9taXNlLnJlc29sdmUoKSl9fSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBtLmNhbmNlbCgpLHY/di51bnN1YnNjcmliZSgpOlByb21pc2UucmVzb2x2ZSgpfX19KGkse0V2ZW50U291cmNlOm0sZ2V0RG9jdW1lbnRzOmh9KX1leHBvcnR7dyBhcyBncm9xU3RvcmV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvcS1zdG9yZS5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@sanity/groq-store/dist/browser/groq-store.modern.mjs\n"));

/***/ }),

/***/ "./node_modules/groq-js/dist/1.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/groq-js/dist/1.esm.mjs ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evaluate\": function() { return /* binding */ evaluateQuery; },\n/* harmony export */   \"parse\": function() { return /* binding */ parse; }\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}var MarkProcessor = /** @class */ (function () {\n    function MarkProcessor(string, marks, parseOptions) {\n        this.allowBoost = false;\n        this.string = string;\n        this.marks = marks;\n        this.index = 0;\n        this.parseOptions = parseOptions;\n    }\n    MarkProcessor.prototype.hasMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.index + pos < this.marks.length;\n    };\n    MarkProcessor.prototype.getMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.marks[this.index + pos];\n    };\n    MarkProcessor.prototype.shift = function () {\n        this.index += 1;\n    };\n    MarkProcessor.prototype.process = function (visitor) {\n        var mark = this.marks[this.index];\n        this.shift();\n        var func = visitor[mark.name];\n        if (!func) {\n            throw new Error(\"Unknown handler: \".concat(mark.name));\n        }\n        return func.call(visitor, this, mark);\n    };\n    MarkProcessor.prototype.processString = function () {\n        this.shift();\n        return this.processStringEnd();\n    };\n    MarkProcessor.prototype.processStringEnd = function () {\n        var prev = this.marks[this.index - 1];\n        var curr = this.marks[this.index];\n        this.shift();\n        return this.string.slice(prev.position, curr.position);\n    };\n    MarkProcessor.prototype.slice = function (len) {\n        var pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    };\n    return MarkProcessor;\n}());var RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    if (RFC3339_REGEX.test(str)) {\n        return new Date(str);\n    }\n    return null;\n}\nfunction formatRFC3339(d) {\n    var year = addLeadingZero(d.getUTCFullYear(), 4);\n    var month = addLeadingZero(d.getUTCMonth() + 1, 2);\n    var day = addLeadingZero(d.getUTCDate(), 2);\n    var hour = addLeadingZero(d.getUTCHours(), 2);\n    var minute = addLeadingZero(d.getUTCMinutes(), 2);\n    var second = addLeadingZero(d.getUTCSeconds(), 2);\n    var fractionalSecond = '';\n    var millis = d.getMilliseconds();\n    if (millis != 0) {\n        fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n    }\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n    var str = num.toString();\n    while (str.length < targetLength) {\n        str = \"0\".concat(str);\n    }\n    return str;\n}function escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction pathRegExp(pattern) {\n    var re = [];\n    for (var _i = 0, _a = pattern.split('.'); _i < _a.length; _i++) {\n        var part = _a[_i];\n        if (part === '*') {\n            re.push('[^.]+');\n        }\n        else if (part === '**') {\n            re.push('.*');\n        }\n        else {\n            re.push(escapeRegExp(part));\n        }\n    }\n    return new RegExp(\"^\".concat(re.join('.'), \"$\"));\n}\nvar Path = /** @class */ (function () {\n    function Path(pattern) {\n        this.pattern = pattern;\n        this.patternRe = pathRegExp(pattern);\n    }\n    Path.prototype.matches = function (str) {\n        return this.patternRe.test(str);\n    };\n    Path.prototype.toJSON = function () {\n        return this.pattern;\n    };\n    return Path;\n}());var StreamValue = /** @class */ (function () {\n    function StreamValue(generator) {\n        this.type = 'stream';\n        this.generator = generator;\n        this.ticker = null;\n        this.isDone = false;\n        this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    StreamValue.prototype.isArray = function () {\n        return true;\n    };\n    StreamValue.prototype.get = function () {\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _b, _c, value, _d, _e, e_1_1;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        result = [];\n                        _f.label = 1;\n                    case 1:\n                        _f.trys.push([1, 7, 8, 13]);\n                        _b = __asyncValues(this);\n                        _f.label = 2;\n                    case 2: return [4 /*yield*/, _b.next()];\n                    case 3:\n                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 6];\n                        value = _c.value;\n                        _e = (_d = result).push;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _e.apply(_d, [_f.sent()]);\n                        _f.label = 5;\n                    case 5: return [3 /*break*/, 2];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_1_1 = _f.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _f.trys.push([8, , 11, 12]);\n                        if (!(_c && !_c.done && (_a = _b[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _a.call(_b)];\n                    case 9:\n                        _f.sent();\n                        _f.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    StreamValue.prototype[Symbol.asyncIterator] = function () {\n        return __asyncGenerator(this, arguments, function _a() {\n            var i;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        _b.label = 2;\n                    case 2:\n                        if (!(i < this.data.length)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, __await(this.data[i])];\n                    case 3: return [4 /*yield*/, _b.sent()];\n                    case 4:\n                        _b.sent();\n                        _b.label = 5;\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 2];\n                    case 6:\n                        if (!this.isDone) return [3 /*break*/, 8];\n                        return [4 /*yield*/, __await(void 0)];\n                    case 7: return [2 /*return*/, _b.sent()];\n                    case 8: return [4 /*yield*/, __await(this._nextTick())];\n                    case 9:\n                        _b.sent();\n                        return [3 /*break*/, 1];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    StreamValue.prototype._nextTick = function () {\n        var _this = this;\n        if (this.ticker) {\n            return this.ticker;\n        }\n        var currentResolver;\n        var setupTicker = function () {\n            _this.ticker = new Promise(function (resolve) {\n                currentResolver = resolve;\n            });\n        };\n        var tick = function () {\n            currentResolver();\n            setupTicker();\n        };\n        var fetch = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b, value, e_2_1;\n            var e_2, _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 5, 6, 11]);\n                        _a = __asyncValues(this.generator());\n                        _d.label = 1;\n                    case 1: return [4 /*yield*/, _a.next()];\n                    case 2:\n                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 4];\n                        value = _b.value;\n                        this.data.push(value);\n                        tick();\n                        _d.label = 3;\n                    case 3: return [3 /*break*/, 1];\n                    case 4: return [3 /*break*/, 11];\n                    case 5:\n                        e_2_1 = _d.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 11];\n                    case 6:\n                        _d.trys.push([6, , 9, 10]);\n                        if (!(_b && !_b.done && (_c = _a[\"return\"]))) return [3 /*break*/, 8];\n                        return [4 /*yield*/, _c.call(_a)];\n                    case 7:\n                        _d.sent();\n                        _d.label = 8;\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 10: return [7 /*endfinally*/];\n                    case 11:\n                        this.isDone = true;\n                        tick();\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        setupTicker();\n        fetch();\n        return this.ticker;\n    };\n    return StreamValue;\n}());var StaticValue = /** @class */ (function () {\n    function StaticValue(data, type) {\n        this.data = data;\n        this.type = type;\n    }\n    StaticValue.prototype.isArray = function () {\n        return this.type === 'array';\n    };\n    // eslint-disable-next-line require-await\n    StaticValue.prototype.get = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.data];\n            });\n        });\n    };\n    StaticValue.prototype[Symbol.asyncIterator] = function () {\n        if (Array.isArray(this.data)) {\n            return (function (data) {\n                var _i, data_1, element;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            _i = 0, data_1 = data;\n                            _a.label = 1;\n                        case 1:\n                            if (!(_i < data_1.length)) return [3 /*break*/, 4];\n                            element = data_1[_i];\n                            return [4 /*yield*/, fromJS(element)];\n                        case 2:\n                            _a.sent();\n                            _a.label = 3;\n                        case 3:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 4: return [2 /*return*/];\n                    }\n                });\n            })(this.data);\n        }\n        throw new Error(\"Cannot iterate over: \".concat(this.type));\n    };\n    return StaticValue;\n}());\nvar NULL_VALUE = new StaticValue(null, 'null');\nvar TRUE_VALUE = new StaticValue(true, 'boolean');\nvar FALSE_VALUE = new StaticValue(false, 'boolean');\nvar DateTime = /** @class */ (function () {\n    function DateTime(date) {\n        this.date = date;\n    }\n    DateTime.parseToValue = function (str) {\n        var date = parseRFC3339(str);\n        if (date) {\n            return new StaticValue(new DateTime(date), 'datetime');\n        }\n        return NULL_VALUE;\n    };\n    DateTime.prototype.equals = function (other) {\n        return this.date.getTime() == other.date.getTime();\n    };\n    DateTime.prototype.add = function (secs) {\n        var copy = new Date(this.date.getTime());\n        copy.setTime(copy.getTime() + secs * 1000);\n        return new DateTime(copy);\n    };\n    DateTime.prototype.difference = function (other) {\n        return (this.date.getTime() - other.date.getTime()) / 1000;\n    };\n    DateTime.prototype.compareTo = function (other) {\n        return this.date.getTime() - other.date.getTime();\n    };\n    DateTime.prototype.toString = function () {\n        return formatRFC3339(this.date);\n    };\n    DateTime.prototype.toJSON = function () {\n        return this.toString();\n    };\n    return DateTime;\n}());\nfunction fromNumber(num) {\n    if (Number.isFinite(num)) {\n        return new StaticValue(num, 'number');\n    }\n    return NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, 'string');\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, 'datetime');\n}\nfunction fromPath(path) {\n    return new StaticValue(path, 'path');\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next === 'function';\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction fromJS(val) {\n    if (isIterator(val)) {\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var val_1, val_1_1, value, e_1_1;\n                var e_1, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _b.trys.push([0, 7, 8, 13]);\n                            val_1 = __asyncValues(val);\n                            _b.label = 1;\n                        case 1: return [4 /*yield*/, __await(val_1.next())];\n                        case 2:\n                            if (!(val_1_1 = _b.sent(), !val_1_1.done)) return [3 /*break*/, 6];\n                            value = val_1_1.value;\n                            return [4 /*yield*/, __await(fromJS(value))];\n                        case 3: return [4 /*yield*/, _b.sent()];\n                        case 4:\n                            _b.sent();\n                            _b.label = 5;\n                        case 5: return [3 /*break*/, 1];\n                        case 6: return [3 /*break*/, 13];\n                        case 7:\n                            e_1_1 = _b.sent();\n                            e_1 = { error: e_1_1 };\n                            return [3 /*break*/, 13];\n                        case 8:\n                            _b.trys.push([8, , 11, 12]);\n                            if (!(val_1_1 && !val_1_1.done && (_a = val_1[\"return\"]))) return [3 /*break*/, 10];\n                            return [4 /*yield*/, __await(_a.call(val_1))];\n                        case 9:\n                            _b.sent();\n                            _b.label = 10;\n                        case 10: return [3 /*break*/, 12];\n                        case 11:\n                            if (e_1) throw e_1.error;\n                            return [7 /*endfinally*/];\n                        case 12: return [7 /*endfinally*/];\n                        case 13: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    }\n    else if (val === null || val === undefined) {\n        return NULL_VALUE;\n    }\n    return new StaticValue(val, getType(val));\n}\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getType(data) {\n    if (data === null || typeof data === 'undefined') {\n        return 'null';\n    }\n    if (Array.isArray(data)) {\n        return 'array';\n    }\n    if (data instanceof Path) {\n        return 'path';\n    }\n    if (data instanceof DateTime) {\n        return 'datetime';\n    }\n    return typeof data;\n}var TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction partialCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    if (aType !== bType) {\n        return null;\n    }\n    switch (aType) {\n        case 'number':\n        case 'boolean':\n            return a - b;\n        case 'string':\n            if (a < b)\n                return -1;\n            if (a > b)\n                return 1;\n            return 0;\n        case 'datetime':\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction totalCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    var aTypeOrder = TYPE_ORDER[aType] || 100;\n    var bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) {\n        return aTypeOrder - bTypeOrder;\n    }\n    var result = partialCompare(a, b);\n    if (result === null) {\n        result = 0;\n    }\n    return result;\n}var CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nvar MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    if (tokens.length === 0 || patterns.length === 0) {\n        return false;\n    }\n    return patterns.every(function (pattern) { return pattern(tokens); });\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, '').match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    var termsRe = matchPatternRegex(text);\n    return termsRe.map(function (re) { return function (tokens) { return tokens.some(function (token) { return re.test(token); }); }; });\n}\nfunction matchPatternRegex(text) {\n    var terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || [];\n    return terms.map(function (term) { return new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*'), \"$\"), 'i'); });\n}\nfunction gatherText(value, cb) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var success, part, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (value.type === 'string') {\n                        cb(value.data);\n                        return [2 /*return*/, true];\n                    }\n                    if (!value.isArray()) return [3 /*break*/, 13];\n                    success = true;\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 6, 7, 12]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 2;\n                case 2: return [4 /*yield*/, value_1.next()];\n                case 3:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 5];\n                    part = value_1_1.value;\n                    if (part.type === 'string') {\n                        cb(part.data);\n                    }\n                    else {\n                        success = false;\n                    }\n                    _b.label = 4;\n                case 4: return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 12];\n                case 6:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 12];\n                case 7:\n                    _b.trys.push([7, , 10, 11]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 9];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 8:\n                    _b.sent();\n                    _b.label = 9;\n                case 9: return [3 /*break*/, 11];\n                case 10:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 11: return [7 /*endfinally*/];\n                case 12: return [2 /*return*/, success];\n                case 13: return [2 /*return*/, false];\n            }\n        });\n    });\n}// BM25 similarity constants\nvar BM25k = 1.2;\nfunction evaluateScore(node, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var innerScore, boost, _a, leftScore, rightScore, leftScore, rightScore, res;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (node.type === 'OpCall' && node.op === 'match') {\n                        return [2 /*return*/, evaluateMatchScore(node.left, node.right, scope, execute)];\n                    }\n                    if (!(node.type === 'FuncCall' && node.name === 'boost')) return [3 /*break*/, 3];\n                    return [4 /*yield*/, evaluateScore(node.args[0], scope, execute)];\n                case 1:\n                    innerScore = _b.sent();\n                    return [4 /*yield*/, execute(node.args[1], scope)];\n                case 2:\n                    boost = _b.sent();\n                    if (boost.type === 'number' && innerScore > 0) {\n                        return [2 /*return*/, innerScore + boost.data];\n                    }\n                    return [2 /*return*/, 0];\n                case 3:\n                    _a = node.type;\n                    switch (_a) {\n                        case 'Or': return [3 /*break*/, 4];\n                        case 'And': return [3 /*break*/, 7];\n                    }\n                    return [3 /*break*/, 10];\n                case 4: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 5:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 6:\n                    rightScore = _b.sent();\n                    return [2 /*return*/, leftScore + rightScore];\n                case 7: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 8:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 9:\n                    rightScore = _b.sent();\n                    if (leftScore === 0 || rightScore === 0)\n                        return [2 /*return*/, 0];\n                    return [2 /*return*/, leftScore + rightScore];\n                case 10: return [4 /*yield*/, execute(node, scope)];\n                case 11:\n                    res = _b.sent();\n                    return [2 /*return*/, res.type === 'boolean' && res.data === true ? 1 : 0];\n            }\n        });\n    });\n}\nfunction evaluateMatchScore(left, right, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var text, pattern, tokens, terms, didSucceed, score, _loop_1, _i, terms_1, re;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(left, scope)];\n                case 1:\n                    text = _a.sent();\n                    return [4 /*yield*/, execute(right, scope)];\n                case 2:\n                    pattern = _a.sent();\n                    tokens = [];\n                    terms = [];\n                    return [4 /*yield*/, gatherText(text, function (part) {\n                            tokens = tokens.concat(matchTokenize(part));\n                        })];\n                case 3:\n                    _a.sent();\n                    return [4 /*yield*/, gatherText(pattern, function (part) {\n                            terms = terms.concat(matchPatternRegex(part));\n                        })];\n                case 4:\n                    didSucceed = _a.sent();\n                    if (!didSucceed) {\n                        return [2 /*return*/, 0];\n                    }\n                    if (tokens.length === 0 || terms.length === 0) {\n                        return [2 /*return*/, 0];\n                    }\n                    score = 0;\n                    _loop_1 = function (re) {\n                        var freq = tokens.reduce(function (c, token) { return c + (re.test(token) ? 1 : 0); }, 0);\n                        score += (freq * (BM25k + 1)) / (freq + BM25k);\n                    };\n                    for (_i = 0, terms_1 = terms; _i < terms_1.length; _i++) {\n                        re = terms_1[_i];\n                        _loop_1(re);\n                    }\n                    return [2 /*return*/, score];\n            }\n        });\n    });\n}function portableTextContent(value) {\n    return __awaiter(this, void 0, void 0, function () {\n        var texts;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(value.type === 'object')) return [3 /*break*/, 1];\n                    return [2 /*return*/, blockText(value.data)];\n                case 1:\n                    if (!value.isArray()) return [3 /*break*/, 3];\n                    return [4 /*yield*/, arrayText(value)];\n                case 2:\n                    texts = _a.sent();\n                    if (texts.length > 0) {\n                        return [2 /*return*/, texts.join('\\n\\n')];\n                    }\n                    _a.label = 3;\n                case 3: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction arrayText(value, result) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    if (result === void 0) { result = []; }\n    return __awaiter(this, void 0, void 0, function () {\n        var block, text, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 7, 8, 13]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 1;\n                case 1: return [4 /*yield*/, value_1.next()];\n                case 2:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 6];\n                    block = value_1_1.value;\n                    if (!(block.type === 'object')) return [3 /*break*/, 3];\n                    text = blockText(block.data);\n                    if (text !== null)\n                        result.push(text);\n                    return [3 /*break*/, 5];\n                case 3:\n                    if (!block.isArray()) return [3 /*break*/, 5];\n                    return [4 /*yield*/, arrayText(block, result)];\n                case 4:\n                    _b.sent();\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 1];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, result];\n            }\n        });\n    });\n}\nfunction blockText(obj) {\n    if (typeof obj._type !== 'string')\n        return null;\n    var children = obj.children;\n    if (!Array.isArray(children))\n        return null;\n    var result = '';\n    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n        var child = children_1[_i];\n        if (child &&\n            typeof child === 'object' &&\n            typeof child._type === 'string' &&\n            child._type === 'span' &&\n            typeof child.text === 'string') {\n            result += child.text;\n        }\n    }\n    return result;\n}function hasReference(value, pathSet) {\n    switch (getType(value)) {\n        case 'array':\n            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                var v = value_1[_i];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n        case 'object':\n            if (value._ref) {\n                return pathSet.has(value._ref);\n            }\n            for (var _a = 0, _b = Object.values(value); _a < _b.length; _a++) {\n                var v = _b[_a];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\nfunction countUTF8(str) {\n    var count = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        if (code >= 0xd800 && code <= 0xdbff) {\n            // High surrogate. Don't count this.\n            // By only counting the low surrogate we will correctly\n            // count the number of UTF-8 code points.\n            continue;\n        }\n        count++;\n    }\n    return count;\n}\nvar global = {};\nglobal.anywhere = function anywhere() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            throw new Error('not implemented');\n        });\n    });\n};\nglobal.anywhere.arity = 1;\nglobal.coalesce = function coalesce(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _i, args_1, arg, value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _i = 0, args_1 = args;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < args_1.length)) return [3 /*break*/, 4];\n                    arg = args_1[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    value = _a.sent();\n                    if (value.type !== 'null') {\n                        return [2 /*return*/, value];\n                    }\n                    _a.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.count = function count(args, scope, execute) {\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_1, inner_1_1, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (!inner.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_1 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_1.next()];\n                case 4:\n                    if (!(inner_1_1 = _b.sent(), !inner_1_1.done)) return [3 /*break*/, 6];\n                    inner_1_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_1_1 && !inner_1_1.done && (_a = inner_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n            }\n        });\n    });\n};\nglobal.count.arity = 1;\nglobal.dateTime = function dateTime(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var val;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    val = _a.sent();\n                    if (val.type === 'datetime') {\n                        return [2 /*return*/, val];\n                    }\n                    if (val.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, DateTime.parseToValue(val.data)];\n            }\n        });\n    });\n};\nglobal.dateTime.arity = 1;\nglobal.defined = function defined(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    return [2 /*return*/, inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE];\n            }\n        });\n    });\n};\nglobal.defined.arity = 1;\n// eslint-disable-next-line require-await\nglobal.identity = function identity(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.identity)];\n        });\n    });\n};\nglobal.identity.arity = 0;\nglobal.length = function length(args, scope, execute) {\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_2, inner_2_1, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (inner.type === 'string') {\n                        return [2 /*return*/, fromNumber(countUTF8(inner.data))];\n                    }\n                    if (!inner.isArray()) return [3 /*break*/, 14];\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_2 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_2.next()];\n                case 4:\n                    if (!(inner_2_1 = _b.sent(), !inner_2_1.done)) return [3 /*break*/, 6];\n                    inner_2_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_2_1 && !inner_2_1.done && (_a = inner_2[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_2)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_2) throw e_2.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n                case 14: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.length.arity = 1;\nglobal.path = function path(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    if (inner.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromPath(new Path(inner.data))];\n            }\n        });\n    });\n};\nglobal.path.arity = 1;\nglobal.string = function string(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    switch (value.type) {\n                        case 'number':\n                        case 'string':\n                        case 'boolean':\n                        case 'datetime':\n                            return [2 /*return*/, fromString(\"\".concat(value.data))];\n                        default:\n                            return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n};\nglobal.string.arity = 1;\nglobal.references = function references(args, scope, execute) {\n    var e_3, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var pathSet, _i, args_2, arg, path, path_1, path_1_1, elem, e_3_1, scopeValue;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    pathSet = new Set();\n                    _i = 0, args_2 = args;\n                    _b.label = 1;\n                case 1:\n                    if (!(_i < args_2.length)) return [3 /*break*/, 16];\n                    arg = args_2[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    path = _b.sent();\n                    if (!(path.type === 'string')) return [3 /*break*/, 3];\n                    pathSet.add(path.data);\n                    return [3 /*break*/, 15];\n                case 3:\n                    if (!path.isArray()) return [3 /*break*/, 15];\n                    _b.label = 4;\n                case 4:\n                    _b.trys.push([4, 9, 10, 15]);\n                    path_1 = (e_3 = void 0, __asyncValues(path));\n                    _b.label = 5;\n                case 5: return [4 /*yield*/, path_1.next()];\n                case 6:\n                    if (!(path_1_1 = _b.sent(), !path_1_1.done)) return [3 /*break*/, 8];\n                    elem = path_1_1.value;\n                    if (elem.type === 'string') {\n                        pathSet.add(elem.data);\n                    }\n                    _b.label = 7;\n                case 7: return [3 /*break*/, 5];\n                case 8: return [3 /*break*/, 15];\n                case 9:\n                    e_3_1 = _b.sent();\n                    e_3 = { error: e_3_1 };\n                    return [3 /*break*/, 15];\n                case 10:\n                    _b.trys.push([10, , 13, 14]);\n                    if (!(path_1_1 && !path_1_1.done && (_a = path_1[\"return\"]))) return [3 /*break*/, 12];\n                    return [4 /*yield*/, _a.call(path_1)];\n                case 11:\n                    _b.sent();\n                    _b.label = 12;\n                case 12: return [3 /*break*/, 14];\n                case 13:\n                    if (e_3) throw e_3.error;\n                    return [7 /*endfinally*/];\n                case 14: return [7 /*endfinally*/];\n                case 15:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 16:\n                    if (pathSet.size === 0) {\n                        return [2 /*return*/, FALSE_VALUE];\n                    }\n                    return [4 /*yield*/, scope.value.get()];\n                case 17:\n                    scopeValue = _b.sent();\n                    return [2 /*return*/, hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE];\n            }\n        });\n    });\n};\nglobal.references.arity = function (c) { return c >= 1; };\nglobal.round = function round(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, num, prec, precValue;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = value.data;\n                    prec = 0;\n                    if (!(args.length === 2)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    precValue = _a.sent();\n                    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    prec = precValue.data;\n                    _a.label = 3;\n                case 3:\n                    if (prec === 0) {\n                        if (num < 0) {\n                            // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n                            // The behavior we're interested in is to \"round half away from zero\".\n                            return [2 /*return*/, fromNumber(-Math.round(-num))];\n                        }\n                        return [2 /*return*/, fromNumber(Math.round(num))];\n                    }\n                    return [2 /*return*/, fromNumber(Number(num.toFixed(prec)))];\n            }\n        });\n    });\n};\nglobal.round.arity = function (count) { return count >= 1 && count <= 2; };\n// eslint-disable-next-line require-await\nglobal.now = function now(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.timestamp.toISOString())];\n        });\n    });\n};\nglobal.now.arity = 0;\n// eslint-disable-next-line require-await\nglobal.boost = function boost() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            // This should be handled by the scoring function.\n            throw new Error('unexpected boost call');\n        });\n    });\n};\nglobal.boost.arity = 2;\nvar string = {};\nstring.lower = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toLowerCase())];\n            }\n        });\n    });\n};\nstring.lower.arity = 1;\nstring.upper = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toUpperCase())];\n            }\n        });\n    });\n};\nstring.upper.arity = 1;\nstring.split = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var str, sep;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    str = _a.sent();\n                    if (str.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    sep = _a.sent();\n                    if (sep.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    if (str.data.length === 0) {\n                        return [2 /*return*/, fromJS([])];\n                    }\n                    if (sep.data.length === 0) {\n                        // This uses a Unicode codepoint splitting algorithm\n                        return [2 /*return*/, fromJS(Array.from(str.data))];\n                    }\n                    return [2 /*return*/, fromJS(str.data.split(sep.data))];\n            }\n        });\n    });\n};\nstring.split.arity = 2;\nglobal.lower = string.lower;\nglobal.upper = string.upper;\nstring.startsWith = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var str, prefix;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    str = _a.sent();\n                    if (str.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    prefix = _a.sent();\n                    if (prefix.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE];\n            }\n        });\n    });\n};\nstring.startsWith.arity = 2;\nvar array = {};\narray.join = function (args, scope, execute) {\n    var e_4, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, sep, buf, needSep, arr_1, arr_1_1, elem, e_4_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    sep = _b.sent();\n                    if (sep.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    buf = '';\n                    needSep = false;\n                    _b.label = 3;\n                case 3:\n                    _b.trys.push([3, 8, 9, 14]);\n                    arr_1 = __asyncValues(arr);\n                    _b.label = 4;\n                case 4: return [4 /*yield*/, arr_1.next()];\n                case 5:\n                    if (!(arr_1_1 = _b.sent(), !arr_1_1.done)) return [3 /*break*/, 7];\n                    elem = arr_1_1.value;\n                    if (needSep) {\n                        buf += sep.data;\n                    }\n                    switch (elem.type) {\n                        case 'number':\n                        case 'string':\n                        case 'boolean':\n                        case 'datetime':\n                            buf += \"\".concat(elem.data);\n                            break;\n                        default:\n                            return [2 /*return*/, NULL_VALUE];\n                    }\n                    needSep = true;\n                    _b.label = 6;\n                case 6: return [3 /*break*/, 4];\n                case 7: return [3 /*break*/, 14];\n                case 8:\n                    e_4_1 = _b.sent();\n                    e_4 = { error: e_4_1 };\n                    return [3 /*break*/, 14];\n                case 9:\n                    _b.trys.push([9, , 12, 13]);\n                    if (!(arr_1_1 && !arr_1_1.done && (_a = arr_1[\"return\"]))) return [3 /*break*/, 11];\n                    return [4 /*yield*/, _a.call(arr_1)];\n                case 10:\n                    _b.sent();\n                    _b.label = 11;\n                case 11: return [3 /*break*/, 13];\n                case 12:\n                    if (e_4) throw e_4.error;\n                    return [7 /*endfinally*/];\n                case 13: return [7 /*endfinally*/];\n                case 14: return [2 /*return*/, fromJS(buf)];\n            }\n        });\n    });\n};\narray.join.arity = 2;\narray.compact = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var arr;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _a.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, new StreamValue(function () {\n                            return __asyncGenerator(this, arguments, function () {\n                                var arr_2, arr_2_1, elem, e_5_1;\n                                var e_5, _a;\n                                return __generator(this, function (_b) {\n                                    switch (_b.label) {\n                                        case 0:\n                                            _b.trys.push([0, 7, 8, 13]);\n                                            arr_2 = __asyncValues(arr);\n                                            _b.label = 1;\n                                        case 1: return [4 /*yield*/, __await(arr_2.next())];\n                                        case 2:\n                                            if (!(arr_2_1 = _b.sent(), !arr_2_1.done)) return [3 /*break*/, 6];\n                                            elem = arr_2_1.value;\n                                            if (!(elem.type !== 'null')) return [3 /*break*/, 5];\n                                            return [4 /*yield*/, __await(elem)];\n                                        case 3: return [4 /*yield*/, _b.sent()];\n                                        case 4:\n                                            _b.sent();\n                                            _b.label = 5;\n                                        case 5: return [3 /*break*/, 1];\n                                        case 6: return [3 /*break*/, 13];\n                                        case 7:\n                                            e_5_1 = _b.sent();\n                                            e_5 = { error: e_5_1 };\n                                            return [3 /*break*/, 13];\n                                        case 8:\n                                            _b.trys.push([8, , 11, 12]);\n                                            if (!(arr_2_1 && !arr_2_1.done && (_a = arr_2[\"return\"]))) return [3 /*break*/, 10];\n                                            return [4 /*yield*/, __await(_a.call(arr_2))];\n                                        case 9:\n                                            _b.sent();\n                                            _b.label = 10;\n                                        case 10: return [3 /*break*/, 12];\n                                        case 11:\n                                            if (e_5) throw e_5.error;\n                                            return [7 /*endfinally*/];\n                                        case 12: return [7 /*endfinally*/];\n                                        case 13: return [2 /*return*/];\n                                    }\n                                });\n                            });\n                        })];\n            }\n        });\n    });\n};\narray.compact.arity = 1;\narray.unique = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (!value.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, new StreamValue(function () {\n                            return __asyncGenerator(this, arguments, function () {\n                                var added, value_2, value_2_1, iter, _a, e_6_1;\n                                var e_6, _b;\n                                return __generator(this, function (_c) {\n                                    switch (_c.label) {\n                                        case 0:\n                                            added = new Set();\n                                            _c.label = 1;\n                                        case 1:\n                                            _c.trys.push([1, 13, 14, 19]);\n                                            value_2 = __asyncValues(value);\n                                            _c.label = 2;\n                                        case 2: return [4 /*yield*/, __await(value_2.next())];\n                                        case 3:\n                                            if (!(value_2_1 = _c.sent(), !value_2_1.done)) return [3 /*break*/, 12];\n                                            iter = value_2_1.value;\n                                            _a = iter.type;\n                                            switch (_a) {\n                                                case 'number': return [3 /*break*/, 4];\n                                                case 'string': return [3 /*break*/, 4];\n                                                case 'boolean': return [3 /*break*/, 4];\n                                                case 'datetime': return [3 /*break*/, 4];\n                                            }\n                                            return [3 /*break*/, 8];\n                                        case 4:\n                                            if (!!added.has(iter.data)) return [3 /*break*/, 7];\n                                            added.add(iter.data);\n                                            return [4 /*yield*/, __await(iter)];\n                                        case 5: return [4 /*yield*/, _c.sent()];\n                                        case 6:\n                                            _c.sent();\n                                            _c.label = 7;\n                                        case 7: return [3 /*break*/, 11];\n                                        case 8: return [4 /*yield*/, __await(iter)];\n                                        case 9: return [4 /*yield*/, _c.sent()];\n                                        case 10:\n                                            _c.sent();\n                                            _c.label = 11;\n                                        case 11: return [3 /*break*/, 2];\n                                        case 12: return [3 /*break*/, 19];\n                                        case 13:\n                                            e_6_1 = _c.sent();\n                                            e_6 = { error: e_6_1 };\n                                            return [3 /*break*/, 19];\n                                        case 14:\n                                            _c.trys.push([14, , 17, 18]);\n                                            if (!(value_2_1 && !value_2_1.done && (_b = value_2[\"return\"]))) return [3 /*break*/, 16];\n                                            return [4 /*yield*/, __await(_b.call(value_2))];\n                                        case 15:\n                                            _c.sent();\n                                            _c.label = 16;\n                                        case 16: return [3 /*break*/, 18];\n                                        case 17:\n                                            if (e_6) throw e_6.error;\n                                            return [7 /*endfinally*/];\n                                        case 18: return [7 /*endfinally*/];\n                                        case 19: return [2 /*return*/];\n                                    }\n                                });\n                            });\n                        })];\n            }\n        });\n    });\n};\narray.unique.arity = 1;\nvar pt = {};\npt.text = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, text;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    return [4 /*yield*/, portableTextContent(value)];\n                case 2:\n                    text = _a.sent();\n                    if (text === null) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(text)];\n            }\n        });\n    });\n};\npt.text.arity = 1;\nvar sanity = {};\n// eslint-disable-next-line require-await\nsanity.projectId = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.projectId)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\n// eslint-disable-next-line require-await\nsanity.dataset = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.dataset)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\nvar pipeFunctions = {};\npipeFunctions.order = function order(base, args, scope, execute) {\n    var base_1, base_1_1;\n    var e_7, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var mappers, directions, n, _i, args_3, mapper, direction, aux, idx, value, newScope, tuple, i, result, _b, _c, e_7_1;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0: \n                // eslint-disable-next-line max-len\n                // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                return [4 /*yield*/, true];\n                case 1:\n                    // eslint-disable-next-line max-len\n                    // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                    _d.sent();\n                    if (!base.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    mappers = [];\n                    directions = [];\n                    n = 0;\n                    for (_i = 0, args_3 = args; _i < args_3.length; _i++) {\n                        mapper = args_3[_i];\n                        direction = 'asc';\n                        if (mapper.type === 'Desc') {\n                            direction = 'desc';\n                            mapper = mapper.base;\n                        }\n                        else if (mapper.type === 'Asc') {\n                            mapper = mapper.base;\n                        }\n                        mappers.push(mapper);\n                        directions.push(direction);\n                        n++;\n                    }\n                    aux = [];\n                    idx = 0;\n                    _d.label = 2;\n                case 2:\n                    _d.trys.push([2, 13, 14, 19]);\n                    base_1 = __asyncValues(base);\n                    _d.label = 3;\n                case 3: return [4 /*yield*/, base_1.next()];\n                case 4:\n                    if (!(base_1_1 = _d.sent(), !base_1_1.done)) return [3 /*break*/, 12];\n                    value = base_1_1.value;\n                    newScope = scope.createNested(value);\n                    return [4 /*yield*/, value.get()];\n                case 5:\n                    tuple = [_d.sent(), idx];\n                    i = 0;\n                    _d.label = 6;\n                case 6:\n                    if (!(i < n)) return [3 /*break*/, 10];\n                    return [4 /*yield*/, execute(mappers[i], newScope)];\n                case 7:\n                    result = _d.sent();\n                    _c = (_b = tuple).push;\n                    return [4 /*yield*/, result.get()];\n                case 8:\n                    _c.apply(_b, [_d.sent()]);\n                    _d.label = 9;\n                case 9:\n                    i++;\n                    return [3 /*break*/, 6];\n                case 10:\n                    aux.push(tuple);\n                    idx++;\n                    _d.label = 11;\n                case 11: return [3 /*break*/, 3];\n                case 12: return [3 /*break*/, 19];\n                case 13:\n                    e_7_1 = _d.sent();\n                    e_7 = { error: e_7_1 };\n                    return [3 /*break*/, 19];\n                case 14:\n                    _d.trys.push([14, , 17, 18]);\n                    if (!(base_1_1 && !base_1_1.done && (_a = base_1[\"return\"]))) return [3 /*break*/, 16];\n                    return [4 /*yield*/, _a.call(base_1)];\n                case 15:\n                    _d.sent();\n                    _d.label = 16;\n                case 16: return [3 /*break*/, 18];\n                case 17:\n                    if (e_7) throw e_7.error;\n                    return [7 /*endfinally*/];\n                case 18: return [7 /*endfinally*/];\n                case 19:\n                    aux.sort(function (aTuple, bTuple) {\n                        for (var i = 0; i < n; i++) {\n                            var c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n                            if (directions[i] === 'desc') {\n                                c = -c;\n                            }\n                            if (c !== 0) {\n                                return c;\n                            }\n                        }\n                        // Fallback to sorting on the original index for stable sorting.\n                        return aTuple[1] - bTuple[1];\n                    });\n                    return [2 /*return*/, fromJS(aux.map(function (v) { return v[0]; }))];\n            }\n        });\n    });\n};\npipeFunctions.order.arity = function (count) { return count >= 1; };\n// eslint-disable-next-line require-await\npipeFunctions.score = function score(base, args, scope, execute) {\n    var base_2, base_2_1;\n    var e_8, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var unknown, scored, value, _b, _c, newScope, valueScore, _i, args_4, arg, _d, newObject, e_8_1;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (!base.isArray())\n                        return [2 /*return*/, NULL_VALUE\n                            // Anything that isn't an object should be sorted first.\n                        ];\n                    unknown = [];\n                    scored = [];\n                    _e.label = 1;\n                case 1:\n                    _e.trys.push([1, 12, 13, 18]);\n                    base_2 = __asyncValues(base);\n                    _e.label = 2;\n                case 2: return [4 /*yield*/, base_2.next()];\n                case 3:\n                    if (!(base_2_1 = _e.sent(), !base_2_1.done)) return [3 /*break*/, 11];\n                    value = base_2_1.value;\n                    if (!(value.type !== 'object')) return [3 /*break*/, 5];\n                    _c = (_b = unknown).push;\n                    return [4 /*yield*/, value.get()];\n                case 4:\n                    _c.apply(_b, [_e.sent()]);\n                    return [3 /*break*/, 10];\n                case 5:\n                    newScope = scope.createNested(value);\n                    valueScore = typeof value.data._score === 'number' ? value.data._score : 0;\n                    _i = 0, args_4 = args;\n                    _e.label = 6;\n                case 6:\n                    if (!(_i < args_4.length)) return [3 /*break*/, 9];\n                    arg = args_4[_i];\n                    _d = valueScore;\n                    return [4 /*yield*/, evaluateScore(arg, newScope, execute)];\n                case 7:\n                    valueScore = _d + _e.sent();\n                    _e.label = 8;\n                case 8:\n                    _i++;\n                    return [3 /*break*/, 6];\n                case 9:\n                    newObject = Object.assign({}, value.data, { _score: valueScore });\n                    scored.push(newObject);\n                    _e.label = 10;\n                case 10: return [3 /*break*/, 2];\n                case 11: return [3 /*break*/, 18];\n                case 12:\n                    e_8_1 = _e.sent();\n                    e_8 = { error: e_8_1 };\n                    return [3 /*break*/, 18];\n                case 13:\n                    _e.trys.push([13, , 16, 17]);\n                    if (!(base_2_1 && !base_2_1.done && (_a = base_2[\"return\"]))) return [3 /*break*/, 15];\n                    return [4 /*yield*/, _a.call(base_2)];\n                case 14:\n                    _e.sent();\n                    _e.label = 15;\n                case 15: return [3 /*break*/, 17];\n                case 16:\n                    if (e_8) throw e_8.error;\n                    return [7 /*endfinally*/];\n                case 17: return [7 /*endfinally*/];\n                case 18:\n                    scored.sort(function (a, b) { return b._score - a._score; });\n                    return [2 /*return*/, fromJS(scored)];\n            }\n        });\n    });\n};\npipeFunctions.score.arity = function (count) { return count >= 1; };\nvar delta = {};\ndelta.operation = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        var hasBefore, hasAfter;\n        return __generator(this, function (_a) {\n            hasBefore = scope.context.before !== null;\n            hasAfter = scope.context.after !== null;\n            if (hasBefore && hasAfter) {\n                return [2 /*return*/, fromString('update')];\n            }\n            if (hasAfter) {\n                return [2 /*return*/, fromString('create')];\n            }\n            if (hasBefore) {\n                return [2 /*return*/, fromString('delete')];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\ndelta.changedAny = function () {\n    throw new Error('not implemented');\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = 'delta';\ndelta.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = 'delta';\nvar diff = {};\ndiff.changedAny = function () {\n    throw new Error('not implemented');\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndiff.changedOnly.arity = 3;\nvar math = {};\nmath.min = function (args, scope, execute) {\n    var e_9, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, arr_3, arr_3_1, elem, e_9_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = undefined;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_3 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_3.next()];\n                case 4:\n                    if (!(arr_3_1 = _b.sent(), !arr_3_1.done)) return [3 /*break*/, 6];\n                    elem = arr_3_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    if (n === undefined || elem.data < n) {\n                        n = elem.data;\n                    }\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_9_1 = _b.sent();\n                    e_9 = { error: e_9_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_3_1 && !arr_3_1.done && (_a = arr_3[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_3)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_9) throw e_9.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromJS(n)];\n            }\n        });\n    });\n};\nmath.min.arity = 1;\nmath.max = function (args, scope, execute) {\n    var e_10, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, arr_4, arr_4_1, elem, e_10_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = undefined;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_4 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_4.next()];\n                case 4:\n                    if (!(arr_4_1 = _b.sent(), !arr_4_1.done)) return [3 /*break*/, 6];\n                    elem = arr_4_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    if (n === undefined || elem.data > n) {\n                        n = elem.data;\n                    }\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_10_1 = _b.sent();\n                    e_10 = { error: e_10_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_4_1 && !arr_4_1.done && (_a = arr_4[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_4)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_10) throw e_10.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromJS(n)];\n            }\n        });\n    });\n};\nmath.max.arity = 1;\nmath.sum = function (args, scope, execute) {\n    var e_11, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, arr_5, arr_5_1, elem, e_11_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_5 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_5.next()];\n                case 4:\n                    if (!(arr_5_1 = _b.sent(), !arr_5_1.done)) return [3 /*break*/, 6];\n                    elem = arr_5_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n += elem.data;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_11_1 = _b.sent();\n                    e_11 = { error: e_11_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_5_1 && !arr_5_1.done && (_a = arr_5[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_5)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_11) throw e_11.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromJS(n)];\n            }\n        });\n    });\n};\nmath.sum.arity = 1;\nmath.avg = function (args, scope, execute) {\n    var e_12, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, c, arr_6, arr_6_1, elem, e_12_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = 0;\n                    c = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_6 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_6.next()];\n                case 4:\n                    if (!(arr_6_1 = _b.sent(), !arr_6_1.done)) return [3 /*break*/, 6];\n                    elem = arr_6_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n += elem.data;\n                    c++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_12_1 = _b.sent();\n                    e_12 = { error: e_12_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_6_1 && !arr_6_1.done && (_a = arr_6[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_6)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_12) throw e_12.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13:\n                    if (c === 0) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromJS(n / c)];\n            }\n        });\n    });\n};\nmath.avg.arity = 1;\nvar namespaces = {\n    global: global,\n    string: string,\n    array: array,\n    pt: pt,\n    delta: delta,\n    diff: diff,\n    sanity: sanity,\n    math: math\n};const WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\n\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position);\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks);\n          pos = skipWS(str, pos + 1);\n          while (true) {\n            rhs = parseExpr(str, pos, 0);\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position);\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++;\n          marks.push({name: 'tuple_end', position: pos});\n          break\n        }\n        case ')': {\n          pos++;\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks);\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}];\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos});\n            pos = skipWS(str, pos + 3);\n          }\n\n          let res = parseExpr(str, pos, 0);\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++;\n        marks.push({name: 'array_end', position: pos});\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '^': {\n      pos++;\n      marks = [];\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos});\n        pos += 2;\n      }\n      marks.push({name: 'parent', position: startPos});\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}];\n      pos++;\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}];\n      pos++;\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      if (identLen) {\n        pos += 1 + identLen;\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ];\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = 'integer';\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          if (fracLen) {\n            name = 'float';\n            pos += 1 + fracLen;\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci';\n          pos++;\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++;\n          }\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen;\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ];\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        pos += identLen;\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === 'error') return result\n            marks = result.marks;\n            pos = result.position;\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ];\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12;\n  let trav;\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break\n    }\n\n    trav = parseTraversal(str, innerPos);\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos});\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks);\n        pos = trav.position;\n        trav = parseTraversal(str, skipWS(str, pos));\n      }\n      marks.push({name: 'traversal_end', position: pos});\n      continue\n    }\n\n    let token = str[innerPos];\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1];\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks);\n            marks.unshift({name: 'pair', position: startPos});\n            pos = rhs.position;\n            lhsLevel = PREC_PAIR;\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = PREC_COMP;\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'add', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_ADD;\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'sub', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_SUB;\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'pow', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_POW;\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mul', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MUL;\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'div', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_DIV;\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mod', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MOD;\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1;\n        if (str[nextPos] === '=') {\n          nextPos++;\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'or', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_OR;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1);\n          let identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen;\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks);\n            marks.unshift({name: 'pipecall', position: startPos});\n            pos = result.position;\n            lhsLevel = 11;\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'and', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_AND;\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos});\n        pos = innerPos + 4;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos});\n        pos = innerPos + 3;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT);\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2);\n\n            let isGroup = false;\n\n            if (str[pos] === '(') {\n              isGroup = true;\n              pos = skipWS(str, pos + 1);\n            }\n\n            let rangePos = pos;\n            let result = parseExpr(str, pos, PREC_COMP + 1);\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position);\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range';\n              if (str[pos + 2] === '.') {\n                type = 'exc_range';\n                pos = skipWS(str, pos + 3);\n              } else {\n                pos = skipWS(str, pos + 2);\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1);\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos});\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks);\n              pos = rhs.position;\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos});\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n              marks = marks.concat(result.marks);\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos);\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++;\n            }\n\n            lhsLevel = PREC_COMP;\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = 4;\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position;\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos;\n      let identLen = parseRegex(str, pos, IDENT);\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen;\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}];\n      pos += 2;\n\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        );\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos;\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position);\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range';\n        if (str[pos + 2] === '.') {\n          type = 'exc_range';\n          pos += 3;\n        } else {\n          pos += 2;\n        }\n\n        pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position);\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos);\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos});\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos});\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n\n  marks.push({name: 'func_call', position: startPos});\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos});\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen});\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++;\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 1);\n  }\n\n  let lastPos = pos;\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1);\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos});\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}];\n  pos = skipWS(str, pos + 1);\n\n  while (str[pos] !== '}') {\n    let pairPos = pos;\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3);\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos});\n        marks = marks.concat(expr.marks);\n        pos = expr.position;\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos});\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos});\n        marks = marks.concat(expr.marks, value.marks);\n        pos = value.position;\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks);\n        pos = expr.position;\n      }\n    }\n    pos = skipWS(str, pos);\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1);\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++;\n  marks.push({name: 'object_end', position: pos});\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{name: 'str', position: pos}];\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos});\n        pos++;\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos});\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3});\n            pos = str.indexOf('}', pos + 3);\n            marks.push({name: 'unicode_hex_end', position: pos});\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2});\n            marks.push({name: 'unicode_hex_end', position: pos + 6});\n            pos += 5;\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1});\n          pos += 1;\n        }\n        marks.push({name: 'str_start', position: pos + 1});\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null\n}/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a, b) {\n    return function (base) { return b(a(base)); };\n}\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner) {\n    return function (base) { return ({ type: 'Map', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction flatMap(inner) {\n    return function (base) { return ({ type: 'FlatMap', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction traverseArray(build, right) {\n    if (!right) {\n        return {\n            type: 'a-a',\n            build: build\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(build, right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(build, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'a-a',\n                build: join(build, map(right.build))\n            };\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) {\n        return {\n            type: 'a-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'a-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(map(mapper), right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(map(mapper), right.build)\n            };\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}var isEqual = equality;\nfunction equality(a, b) {\n    if ((a.type === 'string' && b.type === 'string') ||\n        (a.type === 'boolean' && b.type === 'boolean') ||\n        (a.type === 'null' && b.type === 'null') ||\n        (a.type === 'number' && b.type === 'number')) {\n        return a.data === b.data;\n    }\n    if (a.type === 'datetime' && b.type === 'datetime') {\n        return a.data.equals(b.data);\n    }\n    return false;\n}var operators = {\n    '==': function eq(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '!=': function neq(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    '>': function gt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '>=': function gte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<': function lt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<=': function lte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    \"in\": function inop(left, right) {\n        var right_1, right_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var b, e_1_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (right.type === 'path') {\n                            if (left.type !== 'string') {\n                                return [2 /*return*/, NULL_VALUE];\n                            }\n                            return [2 /*return*/, right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        if (!right.isArray()) return [3 /*break*/, 13];\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 6, 7, 12]);\n                        right_1 = __asyncValues(right);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, right_1.next()];\n                    case 3:\n                        if (!(right_1_1 = _b.sent(), !right_1_1.done)) return [3 /*break*/, 5];\n                        b = right_1_1.value;\n                        if (isEqual(left, b)) {\n                            return [2 /*return*/, TRUE_VALUE];\n                        }\n                        _b.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _b.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _b.trys.push([7, , 10, 11]);\n                        if (!(right_1_1 && !right_1_1.done && (_a = right_1[\"return\"]))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(right_1)];\n                    case 8:\n                        _b.sent();\n                        _b.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12: return [2 /*return*/, FALSE_VALUE];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    match: function match(left, right) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokens, patterns, didSucceed, matched;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tokens = [];\n                        patterns = [];\n                        return [4 /*yield*/, gatherText(left, function (part) {\n                                tokens = tokens.concat(matchTokenize(part));\n                            })];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, gatherText(right, function (part) {\n                                patterns = patterns.concat(matchAnalyzePattern(part));\n                            })];\n                    case 2:\n                        didSucceed = _a.sent();\n                        if (!didSucceed) {\n                            return [2 /*return*/, FALSE_VALUE];\n                        }\n                        matched = matchText(tokens, patterns);\n                        return [2 /*return*/, matched ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    '+': function plus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data + right.data);\n        }\n        if (left.type === 'string' && right.type === 'string') {\n            return fromString(left.data + right.data);\n        }\n        if (left.type === 'object' && right.type === 'object') {\n            return fromJS(__assign(__assign({}, left.data), right.data));\n        }\n        if (left.type === 'array' && right.type === 'array') {\n            return fromJS(left.data.concat(right.data));\n        }\n        if (left.isArray() && right.isArray()) {\n            return new StreamValue(function () {\n                return __asyncGenerator(this, arguments, function () {\n                    var left_1, left_1_1, val, e_2_1, right_2, right_2_1, val, e_3_1;\n                    var e_2, _a, e_3, _b;\n                    return __generator(this, function (_c) {\n                        switch (_c.label) {\n                            case 0:\n                                _c.trys.push([0, 7, 8, 13]);\n                                left_1 = __asyncValues(left);\n                                _c.label = 1;\n                            case 1: return [4 /*yield*/, __await(left_1.next())];\n                            case 2:\n                                if (!(left_1_1 = _c.sent(), !left_1_1.done)) return [3 /*break*/, 6];\n                                val = left_1_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 3: return [4 /*yield*/, _c.sent()];\n                            case 4:\n                                _c.sent();\n                                _c.label = 5;\n                            case 5: return [3 /*break*/, 1];\n                            case 6: return [3 /*break*/, 13];\n                            case 7:\n                                e_2_1 = _c.sent();\n                                e_2 = { error: e_2_1 };\n                                return [3 /*break*/, 13];\n                            case 8:\n                                _c.trys.push([8, , 11, 12]);\n                                if (!(left_1_1 && !left_1_1.done && (_a = left_1[\"return\"]))) return [3 /*break*/, 10];\n                                return [4 /*yield*/, __await(_a.call(left_1))];\n                            case 9:\n                                _c.sent();\n                                _c.label = 10;\n                            case 10: return [3 /*break*/, 12];\n                            case 11:\n                                if (e_2) throw e_2.error;\n                                return [7 /*endfinally*/];\n                            case 12: return [7 /*endfinally*/];\n                            case 13:\n                                _c.trys.push([13, 20, 21, 26]);\n                                right_2 = __asyncValues(right);\n                                _c.label = 14;\n                            case 14: return [4 /*yield*/, __await(right_2.next())];\n                            case 15:\n                                if (!(right_2_1 = _c.sent(), !right_2_1.done)) return [3 /*break*/, 19];\n                                val = right_2_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 16: return [4 /*yield*/, _c.sent()];\n                            case 17:\n                                _c.sent();\n                                _c.label = 18;\n                            case 18: return [3 /*break*/, 14];\n                            case 19: return [3 /*break*/, 26];\n                            case 20:\n                                e_3_1 = _c.sent();\n                                e_3 = { error: e_3_1 };\n                                return [3 /*break*/, 26];\n                            case 21:\n                                _c.trys.push([21, , 24, 25]);\n                                if (!(right_2_1 && !right_2_1.done && (_b = right_2[\"return\"]))) return [3 /*break*/, 23];\n                                return [4 /*yield*/, __await(_b.call(right_2))];\n                            case 22:\n                                _c.sent();\n                                _c.label = 23;\n                            case 23: return [3 /*break*/, 25];\n                            case 24:\n                                if (e_3) throw e_3.error;\n                                return [7 /*endfinally*/];\n                            case 25: return [7 /*endfinally*/];\n                            case 26: return [2 /*return*/];\n                        }\n                    });\n                });\n            });\n        }\n        return NULL_VALUE;\n    },\n    '-': function minus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(-right.data));\n        }\n        if (left.type === 'datetime' && right.type === 'datetime') {\n            return fromNumber(left.data.difference(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data - right.data);\n        }\n        return NULL_VALUE;\n    },\n    '*': numericOperator(function (a, b) { return a * b; }),\n    '/': numericOperator(function (a, b) { return a / b; }),\n    '%': numericOperator(function (a, b) { return a % b; }),\n    '**': numericOperator(function (a, b) { return Math.pow(a, b); })\n};\nfunction numericOperator(impl) {\n    return function (left, right) {\n        if (left.type === 'number' && right.type === 'number') {\n            var result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}var Scope = /** @class */ (function () {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    function Scope(params, source, value, context, parent) {\n        this.isHidden = false;\n        this.params = params;\n        this.source = source;\n        this.value = value;\n        this.context = context;\n        this.parent = parent;\n    }\n    Scope.prototype.createNested = function (value) {\n        if (this.isHidden) {\n            return new Scope(this.params, this.source, value, this.context, this.parent);\n        }\n        return new Scope(this.params, this.source, value, this.context, this);\n    };\n    Scope.prototype.createHidden = function (value) {\n        var result = this.createNested(value);\n        result.isHidden = true;\n        return result;\n    };\n    return Scope;\n}());function evaluate(node, scope, execute) {\n    if (execute === void 0) { execute = evaluate; }\n    var func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(value, cb) {\n    if ('then' in value) {\n        return value.then(cb);\n    }\n    return cb(value);\n}\nvar EXECUTORS = {\n    This: function (_, scope) {\n        return scope.value;\n    },\n    Selector: function () {\n        // These should be evaluated separely using a different evaluator.\n        // At the mooment we haven't implemented this.\n        throw new Error('Selectors can not be evaluated');\n    },\n    Everything: function (_, scope) {\n        return scope.source;\n    },\n    Parameter: function (_a, scope) {\n        var name = _a.name;\n        return fromJS(scope.params[name]);\n    },\n    Context: function (_a, scope) {\n        var key = _a.key;\n        if (key === 'before' || key === 'after') {\n            var value = scope.context[key];\n            return value || NULL_VALUE;\n        }\n        throw new Error(\"unknown context key: \".concat(key));\n    },\n    Parent: function (_a, scope) {\n        var n = _a.n;\n        var current = scope;\n        for (var i = 0; i < n; i++) {\n            if (!current.parent) {\n                return NULL_VALUE;\n            }\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall: function (_a, scope, execute) {\n        var _this = this;\n        var op = _a.op, left = _a.left, right = _a.right;\n        var func = operators[op];\n        if (!func) {\n            throw new Error(\"Unknown operator: \".concat(op));\n        }\n        var leftValue = execute(left, scope);\n        var rightValue = execute(right, scope);\n        // Avoid uneccesary promises\n        // This is required for constant evaluation to work correctly.\n        if ('then' in leftValue || 'then' in rightValue) {\n            return (function () { return __awaiter(_this, void 0, void 0, function () { var _a, _b; return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = func;\n                        return [4 /*yield*/, leftValue];\n                    case 1:\n                        _b = [_c.sent()];\n                        return [4 /*yield*/, rightValue];\n                    case 2: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()]))];\n                }\n            }); }); })();\n        }\n        return func(leftValue, rightValue);\n    },\n    Select: function (_a, scope, execute) {\n        var alternatives = _a.alternatives, fallback = _a.fallback;\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, alternatives_1, alt, altCond;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _i = 0, alternatives_1 = alternatives;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < alternatives_1.length)) return [3 /*break*/, 4];\n                        alt = alternatives_1[_i];\n                        return [4 /*yield*/, execute(alt.condition, scope)];\n                    case 2:\n                        altCond = _b.sent();\n                        if (altCond.type === 'boolean' && altCond.data === true) {\n                            return [2 /*return*/, execute(alt.value, scope)];\n                        }\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (fallback) {\n                            return [2 /*return*/, execute(fallback, scope)];\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    InRange: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, leftValue, rightValue, leftCmp, _b, _c, rightCmp, _d, _e;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _f.sent();\n                        return [4 /*yield*/, execute(left, scope)];\n                    case 2:\n                        leftValue = _f.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 3:\n                        rightValue = _f.sent();\n                        _b = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c = [_f.sent()];\n                        return [4 /*yield*/, leftValue.get()];\n                    case 5:\n                        leftCmp = _b.apply(void 0, _c.concat([_f.sent()]));\n                        if (leftCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _d = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 6:\n                        _e = [_f.sent()];\n                        return [4 /*yield*/, rightValue.get()];\n                    case 7:\n                        rightCmp = _d.apply(void 0, _e.concat([_f.sent()]));\n                        if (rightCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (isInclusive) {\n                            return [2 /*return*/, leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        return [2 /*return*/, leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    Filter: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var baseValue_1, baseValue_1_1, elem, newScope, exprValue, e_1_1;\n                                    var e_1, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                baseValue_1 = __asyncValues(baseValue);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(baseValue_1.next())];\n                                            case 2:\n                                                if (!(baseValue_1_1 = _b.sent(), !baseValue_1_1.done)) return [3 /*break*/, 7];\n                                                elem = baseValue_1_1.value;\n                                                newScope = scope.createNested(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                exprValue = _b.sent();\n                                                if (!(exprValue.type === 'boolean' && exprValue.data === true)) return [3 /*break*/, 6];\n                                                return [4 /*yield*/, __await(elem)];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_1_1 = _b.sent();\n                                                e_1 = { error: e_1_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(baseValue_1_1 && !baseValue_1_1.done && (_a = baseValue_1[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(baseValue_1))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_1) throw e_1.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    Projection: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, newScope;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (baseValue.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        newScope = scope.createNested(baseValue);\n                        return [2 /*return*/, execute(expr, newScope)];\n                }\n            });\n        });\n    },\n    FuncCall: function (_a, scope, execute) {\n        var func = _a.func, args = _a.args;\n        return func(args, scope, execute);\n    },\n    PipeFuncCall: function (_a, scope, execute) {\n        var func = _a.func, base = _a.base, args = _a.args;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        return [2 /*return*/, func(baseValue, args, scope, execute)];\n                }\n            });\n        });\n    },\n    AccessAttribute: function (_a, scope, execute) {\n        var base = _a.base, name = _a.name;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        value = scope.value;\n                        if (!base) return [3 /*break*/, 2];\n                        return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        if (value.type === 'object') {\n                            if (value.data.hasOwnProperty(name)) {\n                                return [2 /*return*/, fromJS(value.data[name])];\n                            }\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    AccessElement: function (_a, scope, execute) {\n        var base = _a.base, index = _a.index;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, data, finalIndex;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        data = _b.sent();\n                        finalIndex = index < 0 ? index + data.length : index;\n                        return [2 /*return*/, fromJS(data[finalIndex])];\n                }\n            });\n        });\n    },\n    Slice: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, array, leftIdx, rightIdx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        array = (_b.sent());\n                        leftIdx = left;\n                        rightIdx = right;\n                        // Handle negative index\n                        if (leftIdx < 0) {\n                            leftIdx = array.length + leftIdx;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = array.length + rightIdx;\n                        }\n                        // Convert from inclusive to exclusive index\n                        if (isInclusive) {\n                            rightIdx++;\n                        }\n                        if (leftIdx < 0) {\n                            leftIdx = 0;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = 0;\n                        }\n                        // Note: At this point the indices might point out-of-bound, but\n                        // .slice handles this correctly.\n                        return [2 /*return*/, fromJS(array.slice(leftIdx, rightIdx))];\n                }\n            });\n        });\n    },\n    Deref: function (_a, scope, execute) {\n        var e_2, _b;\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, id, _c, _d, doc, e_2_1;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _e.sent();\n                        if (!scope.source.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (value.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        id = value.data._ref;\n                        if (typeof id !== 'string') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _e.label = 2;\n                    case 2:\n                        _e.trys.push([2, 7, 8, 13]);\n                        _c = __asyncValues(scope.source);\n                        _e.label = 3;\n                    case 3: return [4 /*yield*/, _c.next()];\n                    case 4:\n                        if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 6];\n                        doc = _d.value;\n                        if (doc.type === 'object' && id === doc.data._id) {\n                            return [2 /*return*/, doc];\n                        }\n                        _e.label = 5;\n                    case 5: return [3 /*break*/, 3];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_2_1 = _e.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _e.trys.push([8, , 11, 12]);\n                        if (!(_d && !_d.done && (_b = _c[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _b.call(_c)];\n                    case 9:\n                        _e.sent();\n                        _e.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    Value: function (_a) {\n        var value = _a.value;\n        return fromJS(value);\n    },\n    Group: function (_a, scope, execute) {\n        var base = _a.base;\n        return execute(base, scope);\n    },\n    Object: function (_a, scope, execute) {\n        var attributes = _a.attributes;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _i, attributes_1, attr, attrType, _b, value, _c, _d, cond, value, value;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        result = {};\n                        _i = 0, attributes_1 = attributes;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < attributes_1.length)) return [3 /*break*/, 12];\n                        attr = attributes_1[_i];\n                        attrType = attr.type;\n                        _b = attr.type;\n                        switch (_b) {\n                            case 'ObjectAttributeValue': return [3 /*break*/, 2];\n                            case 'ObjectConditionalSplat': return [3 /*break*/, 5];\n                            case 'ObjectSplat': return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 10];\n                    case 2: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 3:\n                        value = _e.sent();\n                        _c = result;\n                        _d = attr.name;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c[_d] = _e.sent();\n                        return [3 /*break*/, 11];\n                    case 5: return [4 /*yield*/, execute(attr.condition, scope)];\n                    case 6:\n                        cond = _e.sent();\n                        if (cond.type !== 'boolean' || cond.data === false) {\n                            return [3 /*break*/, 11];\n                        }\n                        return [4 /*yield*/, execute(attr.value, scope)];\n                    case 7:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 8: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 9:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 10: throw new Error(\"Unknown node type: \".concat(attrType));\n                    case 11:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 12: return [2 /*return*/, fromJS(result)];\n                }\n            });\n        });\n    },\n    Array: function (_a, scope, execute) {\n        var elements = _a.elements;\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var _i, elements_1, element, value, value_1, value_1_1, v, e_3_1;\n                var e_3, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _i = 0, elements_1 = elements;\n                            _b.label = 1;\n                        case 1:\n                            if (!(_i < elements_1.length)) return [3 /*break*/, 21];\n                            element = elements_1[_i];\n                            return [4 /*yield*/, __await(execute(element.value, scope))];\n                        case 2:\n                            value = _b.sent();\n                            if (!element.isSplat) return [3 /*break*/, 17];\n                            if (!value.isArray()) return [3 /*break*/, 16];\n                            _b.label = 3;\n                        case 3:\n                            _b.trys.push([3, 10, 11, 16]);\n                            value_1 = (e_3 = void 0, __asyncValues(value));\n                            _b.label = 4;\n                        case 4: return [4 /*yield*/, __await(value_1.next())];\n                        case 5:\n                            if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 9];\n                            v = value_1_1.value;\n                            return [4 /*yield*/, __await(v)];\n                        case 6: return [4 /*yield*/, _b.sent()];\n                        case 7:\n                            _b.sent();\n                            _b.label = 8;\n                        case 8: return [3 /*break*/, 4];\n                        case 9: return [3 /*break*/, 16];\n                        case 10:\n                            e_3_1 = _b.sent();\n                            e_3 = { error: e_3_1 };\n                            return [3 /*break*/, 16];\n                        case 11:\n                            _b.trys.push([11, , 14, 15]);\n                            if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 13];\n                            return [4 /*yield*/, __await(_a.call(value_1))];\n                        case 12:\n                            _b.sent();\n                            _b.label = 13;\n                        case 13: return [3 /*break*/, 15];\n                        case 14:\n                            if (e_3) throw e_3.error;\n                            return [7 /*endfinally*/];\n                        case 15: return [7 /*endfinally*/];\n                        case 16: return [3 /*break*/, 20];\n                        case 17: return [4 /*yield*/, __await(value)];\n                        case 18: return [4 /*yield*/, _b.sent()];\n                        case 19:\n                            _b.sent();\n                            _b.label = 20;\n                        case 20:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 21: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    },\n    Tuple: function () {\n        throw new Error('tuples can not be evaluated');\n    },\n    Or: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, FALSE_VALUE];\n                }\n            });\n        });\n    },\n    And: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Not: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (value.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, value.data ? FALSE_VALUE : TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Neg: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(-value.data);\n        });\n    },\n    Pos: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(value.data);\n        });\n    },\n    Asc: function () {\n        return NULL_VALUE;\n    },\n    Desc: function () {\n        return NULL_VALUE;\n    },\n    ArrayCoerce: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        return [2 /*return*/, value.isArray() ? value : NULL_VALUE];\n                }\n            });\n        });\n    },\n    Map: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_2, value_2_1, elem, newScope, e_4_1;\n                                    var e_4, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                value_2 = __asyncValues(value);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_2.next())];\n                                            case 2:\n                                                if (!(value_2_1 = _b.sent(), !value_2_1.done)) return [3 /*break*/, 7];\n                                                elem = value_2_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3: return [4 /*yield*/, __await.apply(void 0, [_b.sent()])];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_4_1 = _b.sent();\n                                                e_4 = { error: e_4_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(value_2_1 && !value_2_1.done && (_a = value_2[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(value_2))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_4) throw e_4.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    FlatMap: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_3, value_3_1, elem, newScope, innerValue, innerValue_1, innerValue_1_1, inner, e_5_1, e_6_1;\n                                    var e_6, _a, e_5, _b;\n                                    return __generator(this, function (_c) {\n                                        switch (_c.label) {\n                                            case 0:\n                                                _c.trys.push([0, 23, 24, 29]);\n                                                value_3 = __asyncValues(value);\n                                                _c.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_3.next())];\n                                            case 2:\n                                                if (!(value_3_1 = _c.sent(), !value_3_1.done)) return [3 /*break*/, 22];\n                                                elem = value_3_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                innerValue = _c.sent();\n                                                if (!innerValue.isArray()) return [3 /*break*/, 18];\n                                                _c.label = 4;\n                                            case 4:\n                                                _c.trys.push([4, 11, 12, 17]);\n                                                innerValue_1 = (e_5 = void 0, __asyncValues(innerValue));\n                                                _c.label = 5;\n                                            case 5: return [4 /*yield*/, __await(innerValue_1.next())];\n                                            case 6:\n                                                if (!(innerValue_1_1 = _c.sent(), !innerValue_1_1.done)) return [3 /*break*/, 10];\n                                                inner = innerValue_1_1.value;\n                                                return [4 /*yield*/, __await(inner)];\n                                            case 7: return [4 /*yield*/, _c.sent()];\n                                            case 8:\n                                                _c.sent();\n                                                _c.label = 9;\n                                            case 9: return [3 /*break*/, 5];\n                                            case 10: return [3 /*break*/, 17];\n                                            case 11:\n                                                e_5_1 = _c.sent();\n                                                e_5 = { error: e_5_1 };\n                                                return [3 /*break*/, 17];\n                                            case 12:\n                                                _c.trys.push([12, , 15, 16]);\n                                                if (!(innerValue_1_1 && !innerValue_1_1.done && (_b = innerValue_1[\"return\"]))) return [3 /*break*/, 14];\n                                                return [4 /*yield*/, __await(_b.call(innerValue_1))];\n                                            case 13:\n                                                _c.sent();\n                                                _c.label = 14;\n                                            case 14: return [3 /*break*/, 16];\n                                            case 15:\n                                                if (e_5) throw e_5.error;\n                                                return [7 /*endfinally*/];\n                                            case 16: return [7 /*endfinally*/];\n                                            case 17: return [3 /*break*/, 21];\n                                            case 18: return [4 /*yield*/, __await(innerValue)];\n                                            case 19: return [4 /*yield*/, _c.sent()];\n                                            case 20:\n                                                _c.sent();\n                                                _c.label = 21;\n                                            case 21: return [3 /*break*/, 1];\n                                            case 22: return [3 /*break*/, 29];\n                                            case 23:\n                                                e_6_1 = _c.sent();\n                                                e_6 = { error: e_6_1 };\n                                                return [3 /*break*/, 29];\n                                            case 24:\n                                                _c.trys.push([24, , 27, 28]);\n                                                if (!(value_3_1 && !value_3_1.done && (_a = value_3[\"return\"]))) return [3 /*break*/, 26];\n                                                return [4 /*yield*/, __await(_a.call(value_3))];\n                                            case 25:\n                                                _c.sent();\n                                                _c.label = 26;\n                                            case 26: return [3 /*break*/, 28];\n                                            case 27:\n                                                if (e_6) throw e_6.error;\n                                                return [7 /*endfinally*/];\n                                            case 28: return [7 /*endfinally*/];\n                                            case 29: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    }\n};\n/**\n * Evaluates a query.\n */\nfunction evaluateQuery(tree, options) {\n    if (options === void 0) { options = {}; }\n    var root = fromJS(options.root);\n    var dataset = fromJS(options.dataset);\n    var params = __assign({}, options.params);\n    var scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || new Date(),\n        identity: options.identity === undefined ? 'me' : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null\n    }, null);\n    return evaluate(tree, scope);\n}function canConstantEvaluate(node) {\n    switch (node.type) {\n        case 'Group':\n        case 'Value':\n        case 'Parameter':\n            return true;\n        case 'Pos':\n        case 'Neg':\n            return canConstantEvaluate(node.base);\n        case 'OpCall':\n            switch (node.op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                case '**':\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nvar DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: 'me', before: null, after: null }, null);\nfunction tryConstantEvaluate(node) {\n    if (!canConstantEvaluate(node)) {\n        return null;\n    }\n    return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n    var value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if ('then' in value) {\n        throw new Error('BUG: constant evaluate should never return a promise');\n    }\n    return value;\n}var ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '\\\\': '\\\\',\n    '/': '/',\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n};\nfunction expandHex(str) {\n    var charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nvar GroqQueryError = /** @class */ (function (_super) {\n    __extends(GroqQueryError, _super);\n    function GroqQueryError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = 'GroqQueryError';\n        return _this;\n    }\n    return GroqQueryError;\n}(Error));\nvar EXPR_BUILDER = {\n    group: function (p) {\n        var inner = p.process(EXPR_BUILDER);\n        return {\n            type: 'Group',\n            base: inner\n        };\n    },\n    everything: function () {\n        return { type: 'Everything' };\n    },\n    \"this\": function () {\n        return { type: 'This' };\n    },\n    parent: function () {\n        return {\n            type: 'Parent',\n            n: 1\n        };\n    },\n    dblparent: function (p) {\n        var next = p.process(EXPR_BUILDER);\n        return {\n            type: 'Parent',\n            n: next.n + 1\n        };\n    },\n    traverse: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var traversalList = [];\n        while (p.getMark().name !== 'traversal_end') {\n            traversalList.push(p.process(TRAVERSE_BUILDER));\n        }\n        p.shift();\n        var traversal = null;\n        for (var i = traversalList.length - 1; i >= 0; i--) {\n            traversal = traversalList[i](traversal);\n        }\n        if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n            traversal = traverseArray(function (val) { return val; }, traversal);\n        }\n        if (traversal === null)\n            throw new Error('BUG: unexpected empty traversal');\n        return traversal.build(base);\n    },\n    this_attr: function (p) {\n        var name = p.processString();\n        if (name === 'null') {\n            return { type: 'Value', value: null };\n        }\n        if (name === 'true') {\n            return { type: 'Value', value: true };\n        }\n        if (name === 'false') {\n            return { type: 'Value', value: false };\n        }\n        return {\n            type: 'AccessAttribute',\n            name: name\n        };\n    },\n    neg: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Neg',\n            base: base\n        };\n    },\n    pos: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Pos',\n            base: base\n        };\n    },\n    add: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '+',\n            left: left,\n            right: right\n        };\n    },\n    sub: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '-',\n            left: left,\n            right: right\n        };\n    },\n    mul: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '*',\n            left: left,\n            right: right\n        };\n    },\n    div: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '/',\n            left: left,\n            right: right\n        };\n    },\n    mod: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '%',\n            left: left,\n            right: right\n        };\n    },\n    pow: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '**',\n            left: left,\n            right: right\n        };\n    },\n    comp: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var op = p.processString();\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: op,\n            left: left,\n            right: right\n        };\n    },\n    in_range: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'InRange',\n            base: base,\n            left: left,\n            right: right,\n            isInclusive: isInclusive\n        };\n    },\n    str: function (p) {\n        var value = '';\n        // eslint-disable-next-line no-labels\n        loop: while (p.hasMark()) {\n            var mark = p.getMark();\n            switch (mark.name) {\n                case 'str_end':\n                    value += p.processStringEnd();\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                case 'str_pause':\n                    value += p.processStringEnd();\n                    break;\n                case 'str_start':\n                    p.shift();\n                    break;\n                case 'single_escape': {\n                    var char = p.slice(1);\n                    p.shift();\n                    value += ESCAPE_SEQUENCE[char];\n                    break;\n                }\n                case 'unicode_hex':\n                    p.shift();\n                    value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(\"unexpected mark: \".concat(mark.name));\n            }\n        }\n        return { type: 'Value', value: value };\n    },\n    integer: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    float: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    sci: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    object: function (p) {\n        var attributes = [];\n        while (p.getMark().name !== 'object_end') {\n            attributes.push(p.process(OBJECT_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Object',\n            attributes: attributes\n        };\n    },\n    array: function (p) {\n        var elements = [];\n        while (p.getMark().name !== 'array_end') {\n            var isSplat = false;\n            if (p.getMark().name === 'array_splat') {\n                isSplat = true;\n                p.shift();\n            }\n            var value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: 'ArrayElement',\n                value: value,\n                isSplat: isSplat\n            });\n        }\n        p.shift();\n        return {\n            type: 'Array',\n            elements: elements\n        };\n    },\n    tuple: function (p) {\n        var members = [];\n        while (p.getMark().name !== 'tuple_end') {\n            members.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Tuple',\n            members: members\n        };\n    },\n    func_call: function (p) {\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        var name = p.processString();\n        if (namespace === 'global' && name === 'select') {\n            var result = {\n                type: 'Select',\n                alternatives: []\n            };\n            while (p.getMark().name !== 'func_args_end') {\n                if (p.getMark().name === 'pair') {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    p.shift();\n                    var condition = p.process(EXPR_BUILDER);\n                    var value = p.process(EXPR_BUILDER);\n                    result.alternatives.push({\n                        type: 'SelectAlternative',\n                        condition: condition,\n                        value: value\n                    });\n                }\n                else {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    var value = p.process(EXPR_BUILDER);\n                    result.fallback = value;\n                }\n            }\n            p.shift();\n            return result;\n        }\n        var args = [];\n        while (p.getMark().name !== 'func_args_end') {\n            if (argumentShouldBeSelector(namespace, name, args.length)) {\n                // Since the diff/delta functions aren't validated yet we only want to validate the selector\n                // being used. We expect the null valued arg to throw an error at evaluation time.\n                p.process(SELECTOR_BUILDER);\n                args.push({ type: 'Selector' });\n            }\n            else {\n                args.push(p.process(EXPR_BUILDER));\n            }\n        }\n        p.shift();\n        if (namespace === 'global' && (name === 'before' || name === 'after')) {\n            if (p.parseOptions.mode === 'delta') {\n                return {\n                    type: 'Context',\n                    key: name\n                };\n            }\n        }\n        if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n            throw new GroqQueryError('unexpected boost');\n        var funcs = namespaces[namespace];\n        if (!funcs) {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var func = funcs[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        if (func.arity !== undefined) {\n            validateArity(name, func.arity, args.length);\n        }\n        if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        return {\n            type: 'FuncCall',\n            func: func,\n            name: name,\n            args: args\n        };\n    },\n    pipecall: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        p.shift(); // Remove the func_call\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        if (namespace !== 'global') {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var name = p.processString();\n        var args = [];\n        var oldAllowBoost = p.allowBoost;\n        if (name === 'score') {\n            // Only allow boost inside a score expression\n            p.allowBoost = true;\n        }\n        for (;;) {\n            var markName = p.getMark().name;\n            if (markName === 'func_args_end') {\n                break;\n            }\n            if (name === 'order') {\n                if (markName === 'asc') {\n                    p.shift();\n                    args.push({ type: 'Asc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n                else if (markName === 'desc') {\n                    p.shift();\n                    args.push({ type: 'Desc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        p.allowBoost = oldAllowBoost;\n        var func = pipeFunctions[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n        }\n        if (func.arity) {\n            validateArity(name, func.arity, args.length);\n        }\n        return {\n            type: 'PipeFuncCall',\n            func: func,\n            base: base,\n            name: name,\n            args: args\n        };\n    },\n    pair: function (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'And',\n            left: left,\n            right: right\n        };\n    },\n    or: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'Or',\n            left: left,\n            right: right\n        };\n    },\n    not: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Not',\n            base: base\n        };\n    },\n    asc: function (p) {\n        throw new GroqQueryError('unexpected asc');\n    },\n    desc: function (p) {\n        throw new GroqQueryError('unexpected desc');\n    },\n    param: function (p) {\n        var name = p.processString();\n        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n            return {\n                type: 'Value',\n                value: p.parseOptions.params[name]\n            };\n        }\n        return {\n            type: 'Parameter',\n            name: name\n        };\n    }\n};\nvar OBJECT_BUILDER = {\n    object_expr: function (p) {\n        if (p.getMark().name === 'pair') {\n            p.shift();\n            var condition = p.process(EXPR_BUILDER);\n            var value_1 = p.process(EXPR_BUILDER);\n            return {\n                type: 'ObjectConditionalSplat',\n                condition: condition,\n                value: value_1\n            };\n        }\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: extractPropertyKey(value),\n            value: value\n        };\n    },\n    object_pair: function (p) {\n        var name = p.process(EXPR_BUILDER);\n        if (name.type !== 'Value')\n            throw new Error('name must be string');\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: name.value,\n            value: value\n        };\n    },\n    object_splat: function (p) {\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectSplat',\n            value: value\n        };\n    },\n    object_splat_this: function () {\n        return {\n            type: 'ObjectSplat',\n            value: { type: 'This' }\n        };\n    }\n};\nvar TRAVERSE_BUILDER = {\n    square_bracket: function (p) {\n        var expr = p.process(EXPR_BUILDER);\n        var value = tryConstantEvaluate(expr);\n        if (value && value.type === 'number') {\n            return function (right) {\n                return traverseElement(function (base) { return ({ type: 'AccessElement', base: base, index: value.data }); }, right);\n            };\n        }\n        if (value && value.type === 'string') {\n            return function (right) {\n                return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: value.data }); }, right);\n            };\n        }\n        return function (right) {\n            return traverseArray(function (base) { return ({\n                type: 'Filter',\n                base: base,\n                expr: expr\n            }); }, right);\n        };\n    },\n    slice: function (p) {\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        var leftValue = tryConstantEvaluate(left);\n        var rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n            throw new GroqQueryError('slicing must use constant numbers');\n        }\n        return function (rhs) {\n            return traverseArray(function (base) { return ({\n                type: 'Slice',\n                base: base,\n                left: leftValue.data,\n                right: rightValue.data,\n                isInclusive: isInclusive\n            }); }, rhs);\n        };\n    },\n    projection: function (p) {\n        var obj = p.process(EXPR_BUILDER);\n        return function (right) {\n            return traverseProjection(function (base) { return ({ type: 'Projection', base: base, expr: obj }); }, right);\n        };\n    },\n    attr_access: function (p) {\n        var name = p.processString();\n        return function (right) { return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: name }); }, right); };\n    },\n    deref: function (p) {\n        var attr = null;\n        if (p.getMark().name === 'deref_attr') {\n            p.shift();\n            attr = p.processString();\n        }\n        var wrap = function (base) {\n            return attr ? { type: 'AccessAttribute', base: base, name: attr } : base;\n        };\n        return function (right) {\n            return traversePlain(function (base) {\n                return wrap({\n                    type: 'Deref',\n                    base: base\n                });\n            }, right);\n        };\n    },\n    array_postfix: function (p) {\n        return function (right) { return traverseArray(function (base) { return ({ type: 'ArrayCoerce', base: base }); }, right); };\n    }\n};\nvar SELECTOR_BUILDER = {\n    group: function (p) {\n        p.process(SELECTOR_BUILDER);\n        return null;\n    },\n    everything: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    \"this\": function () {\n        throw new Error('Invalid selector syntax');\n    },\n    parent: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    dblparent: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    traverse: function (p) {\n        p.process(SELECTOR_BUILDER);\n        while (p.getMark().name !== 'traversal_end') {\n            p.process(TRAVERSE_BUILDER);\n        }\n        p.shift();\n        return null;\n    },\n    this_attr: function (p) {\n        p.processString();\n        return null;\n    },\n    neg: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pos: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    add: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sub: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mul: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    div: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mod: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pow: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    comp: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    in_range: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    str: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    integer: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    float: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sci: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    object: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    array: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    tuple: function (p) {\n        // This should only throw an error until we add support for tuples in selectors.\n        throw new Error('Invalid selector syntax');\n    },\n    func_call: function (p, mark) {\n        var func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === 'anywhere' && func.args.length === 1)\n            return null;\n        throw new Error('Invalid selector syntax');\n    },\n    pipecall: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pair: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    and: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    or: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    not: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    asc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    desc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    param: function (p) {\n        throw new Error('Invalid selector syntax');\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === 'AccessAttribute' && !node.base) {\n        return node.name;\n    }\n    if (node.type === 'Deref' ||\n        node.type === 'Map' ||\n        node.type === 'Projection' ||\n        node.type === 'Slice' ||\n        node.type === 'Filter' ||\n        node.type === 'AccessElement' ||\n        node.type === 'ArrayCoerce') {\n        return extractPropertyKey(node.base);\n    }\n    throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity === 'number') {\n        if (count !== arity) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n        }\n    }\n    else if (arity) {\n        if (!arity(count)) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n        }\n    }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    var functionsRequiringSelectors = ['changedAny', 'changedOnly'];\n    return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nvar GroqSyntaxError = /** @class */ (function (_super) {\n    __extends(GroqSyntaxError, _super);\n    function GroqSyntaxError(position) {\n        var _this = _super.call(this, \"Syntax error in GROQ query at position \".concat(position)) || this;\n        _this.name = 'GroqSyntaxError';\n        _this.position = position;\n        return _this;\n    }\n    return GroqSyntaxError;\n}(Error));\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nfunction parse(input, options) {\n    if (options === void 0) { options = {}; }\n    var result = parse$1(input);\n    if (result.type === 'error') {\n        throw new GroqSyntaxError(result.position);\n    }\n    var processor = new MarkProcessor(input, result.marks, options);\n    return processor.process(EXPR_BUILDER);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEuZXNtLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLHlCQUF5QixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUMsR0FBRztBQUNyQyw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQkFBMkIsc0NBQXNDLHdCQUF3QixPQUFPO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrRkFBK0Y7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxzQ0FBc0M7QUFDN0c7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix3RUFBd0UsY0FBYztBQUN0RjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0Isb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQsUUFBUTtBQUNSLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVyxzQ0FBc0M7QUFDakQsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLG1DQUFtQztBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNDQUFzQztBQUNyRCxlQUFlLGtDQUFrQztBQUNqRCxlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVELHdCQUF3QiwrQkFBK0IsR0FBRyx1Q0FBdUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQsb0JBQW9CLCtCQUErQixHQUFHLGtDQUFrQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RCxvQkFBb0IsK0JBQStCLEdBQUcsdUNBQXVDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHFDQUFxQztBQUNsRSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0EsY0FBYztBQUNkO0FBQ0EsNkJBQTZCLGlDQUFpQztBQUM5RCwwQkFBMEIsK0JBQStCLEdBQUcsdUNBQXVDO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVELHdCQUF3QiwrQkFBK0IsR0FBRyx1Q0FBdUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdDQUF3QztBQUNuRCxXQUFXLG9DQUFvQztBQUMvQyxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELFdBQVcsa0NBQWtDO0FBQzdDLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBMkM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsOEJBQThCLHVDQUF1QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsNEJBQTRCLHVDQUF1QztBQUNuRTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQ0FBc0M7O0FBRXBEO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RCxnQkFBZ0Isa0NBQWtDLEdBQUcsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLDZCQUE2QixHQUFHLDJDQUEyQztBQUMzRjtBQUNBLGtDQUFrQztBQUNsQztBQUNBLElBQUk7QUFDSixnQkFBZ0Isa0NBQWtDLEdBQUcsaUNBQWlDO0FBQ3RGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxjQUFjLHlDQUF5Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5Qzs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hELFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDLGdCQUFnQjtBQUNoQixrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBLGlDQUFpQztBQUNqQyx3QkFBd0IsdUNBQXVDO0FBQy9ELGdDQUFnQztBQUNoQyx3QkFBd0IsdUNBQXVDO0FBQy9ELFlBQVk7QUFDWix3QkFBd0IsdUNBQXVDO0FBQy9ELHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBLFVBQVU7QUFDVixzQkFBc0IseUNBQXlDO0FBQy9EO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVUsdUNBQXVDLGNBQWMsR0FBRztBQUMvRjtBQUNBO0FBQ0EsNkJBQTZCLFVBQVUsMkNBQTJDLGNBQWMsR0FBRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDLGVBQWU7QUFDMUQsMkNBQTJDLGVBQWU7QUFDMUQsMkNBQTJDLGVBQWU7QUFDMUQsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0wsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFzRCxZQUFZO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxJQUFJO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCLG1FQUFtRTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQTRDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZDQUE2QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVUsc0RBQXNELElBQUk7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsVUFBVSx1REFBdUQsSUFBSTtBQUM1SDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVSwyQ0FBMkMsSUFBSTtBQUNqSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLHVDQUF1QyxVQUFVLGlEQUFpRCxJQUFJO0FBQ3hJLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBa0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyx1Q0FBdUMsVUFBVSxpQ0FBaUMsSUFBSTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLmVzbS5tanM/Y2Q4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn12YXIgTWFya1Byb2Nlc3NvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrUHJvY2Vzc29yKHN0cmluZywgbWFya3MsIHBhcnNlT3B0aW9ucykge1xuICAgICAgICB0aGlzLmFsbG93Qm9vc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuICAgIH1cbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5oYXNNYXJrID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAocG9zID09PSB2b2lkIDApIHsgcG9zID0gMDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUuZ2V0TWFyayA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdm9pZCAwKSB7IHBvcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHZhciBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICAgICAgdGhpcy5zaGlmdCgpO1xuICAgICAgICB2YXIgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGhhbmRsZXI6IFwiLmNvbmNhdChtYXJrLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdO1xuICAgICAgICB2YXIgY3VyciA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XG4gICAgICAgIHRoaXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtQcm9jZXNzb3I7XG59KCkpO3ZhciBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xuICAgIGlmIChSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgICB2YXIgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCk7XG4gICAgdmFyIG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMik7XG4gICAgdmFyIGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKTtcbiAgICB2YXIgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMik7XG4gICAgdmFyIG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKTtcbiAgICB2YXIgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICAgIHZhciBmcmFjdGlvbmFsU2Vjb25kID0gJyc7XG4gICAgdmFyIG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgaWYgKG1pbGxpcyAhPSAwKSB7XG4gICAgICAgIGZyYWN0aW9uYWxTZWNvbmQgPSBcIi5cIi5jb25jYXQoYWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdCh5ZWFyLCBcIi1cIikuY29uY2F0KG1vbnRoLCBcIi1cIikuY29uY2F0KGRheSwgXCJUXCIpLmNvbmNhdChob3VyLCBcIjpcIikuY29uY2F0KG1pbnV0ZSwgXCI6XCIpLmNvbmNhdChzZWNvbmQpLmNvbmNhdChmcmFjdGlvbmFsU2Vjb25kLCBcIlpcIik7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICAgIHZhciBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgICBzdHIgPSBcIjBcIi5jb25jYXQoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuZnVuY3Rpb24gcGF0aFJlZ0V4cChwYXR0ZXJuKSB7XG4gICAgdmFyIHJlID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHBhdHRlcm4uc3BsaXQoJy4nKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XG4gICAgICAgIGlmIChwYXJ0ID09PSAnKicpIHtcbiAgICAgICAgICAgIHJlLnB1c2goJ1teLl0rJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydCA9PT0gJyoqJykge1xuICAgICAgICAgICAgcmUucHVzaCgnLionKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQocmUuam9pbignLicpLCBcIiRcIikpO1xufVxudmFyIFBhdGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0aChwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMucGF0dGVyblJlID0gcGF0aFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG4gICAgUGF0aC5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcbiAgICB9O1xuICAgIFBhdGgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgICB9O1xuICAgIHJldHVybiBQYXRoO1xufSgpKTt2YXIgU3RyZWFtVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyZWFtVmFsdWUoZ2VuZXJhdG9yKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdHJlYW0nO1xuICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBTdHJlYW1WYWx1ZS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdHJlYW1WYWx1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2IsIF9jLCB2YWx1ZSwgX2QsIF9lLCBlXzFfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi50cnlzLnB1c2goWzEsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IF9fYXN5bmNWYWx1ZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgX2IubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2MgPSBfZi5zZW50KCksICFfYy5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSAoX2QgPSByZXN1bHQpLnB1c2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmFwcGx5KF9kLCBbX2Yuc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoX2IpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RyZWFtVmFsdWUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiBfYSgpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IHRoaXMuZGF0YS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodGhpcy5kYXRhW2ldKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRG9uZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZvaWQgMCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodGhpcy5fbmV4dFRpY2soKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0cmVhbVZhbHVlLnByb3RvdHlwZS5fbmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnRpY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50UmVzb2x2ZXI7XG4gICAgICAgIHZhciBzZXR1cFRpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnRpY2tlciA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXNvbHZlcigpO1xuICAgICAgICAgICAgc2V0dXBUaWNrZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZldGNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgdmFsdWUsIGVfMl8xO1xuICAgICAgICAgICAgdmFyIGVfMiwgX2M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzAsIDUsIDYsIDExXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9fYXN5bmNWYWx1ZXModGhpcy5nZW5lcmF0b3IoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2EubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2IgPSBfZC5zZW50KCksICFfYi5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yXzEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzYsICwgOSwgMTBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9iICYmICFfYi5kb25lICYmIChfYyA9IF9hW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2MuY2FsbChfYSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfTtcbiAgICAgICAgc2V0dXBUaWNrZXIoKTtcbiAgICAgICAgZmV0Y2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmVhbVZhbHVlO1xufSgpKTt2YXIgU3RhdGljVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljVmFsdWUoZGF0YSwgdHlwZSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBTdGF0aWNWYWx1ZS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2FycmF5JztcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gICAgU3RhdGljVmFsdWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmRhdGFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RhdGljVmFsdWUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBfaSwgZGF0YV8xLCBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgZGF0YV8xID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBkYXRhXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGRhdGFfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZnJvbUpTKGVsZW1lbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSBvdmVyOiBcIi5jb25jYXQodGhpcy50eXBlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljVmFsdWU7XG59KCkpO1xudmFyIE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgJ251bGwnKTtcbnZhciBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKHRydWUsICdib29sZWFuJyk7XG52YXIgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoZmFsc2UsICdib29sZWFuJyk7XG52YXIgRGF0ZVRpbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVRpbWUoZGF0ZSkge1xuICAgICAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICAgIH1cbiAgICBEYXRlVGltZS5wYXJzZVRvVmFsdWUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBkYXRlID0gcGFyc2VSRkMzMzM5KHN0cik7XG4gICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgJ2RhdGV0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICAgIH07XG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzZWNzKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgICAgIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgICB9O1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS5kaWZmZXJlbmNlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVUaW1lO1xufSgpKTtcbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobnVtLCAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHN0ciwgJ3N0cmluZycpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShkdCwgJ2RhdGV0aW1lJyk7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShwYXRoLCAncGF0aCcpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XG4gICAgaWYgKGlzSXRlcmF0b3IodmFsKSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWxfMSwgdmFsXzFfMSwgdmFsdWUsIGVfMV8xO1xuICAgICAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxfMSA9IF9fYXN5bmNWYWx1ZXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodmFsXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsXzFfMSA9IF9iLnNlbnQoKSwgIXZhbF8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGZyb21KUyh2YWx1ZSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWxfMV8xICYmICF2YWxfMV8xLmRvbmUgJiYgKF9hID0gdmFsXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWxfMSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgICAgcmV0dXJuICdwYXRoJztcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlVGltZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGV0aW1lJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhO1xufXZhciBUWVBFX09SREVSID0ge1xuICAgIGRhdGV0aW1lOiAxLFxuICAgIG51bWJlcjogMixcbiAgICBzdHJpbmc6IDMsXG4gICAgYm9vbGVhbjogNFxufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XG4gICAgdmFyIGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgICB2YXIgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICAgIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN3aXRjaCAoYVR5cGUpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBpZiAoYSA8IGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGEgPiBiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICAgIHZhciBhVHlwZSA9IGdldFR5cGUoYSk7XG4gICAgdmFyIGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgICB2YXIgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMDtcbiAgICB2YXIgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcikge1xuICAgICAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IDA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59dmFyIENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG52YXIgQ0hBUlNfV0lUSF9XSUxEQ0FSRCA9IC8oW14hQCMkJV4mKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG52YXIgRURHRV9DSEFSUyA9IC8oXFxiXFwuK3xcXC4rXFxiKS9nO1xudmFyIE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJucy5ldmVyeShmdW5jdGlvbiAocGF0dGVybikgeyByZXR1cm4gcGF0dGVybih0b2tlbnMpOyB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoVG9rZW5pemUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgJycpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dCkge1xuICAgIHZhciB0ZXJtc1JlID0gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCk7XG4gICAgcmV0dXJuIHRlcm1zUmUubWFwKGZ1bmN0aW9uIChyZSkgeyByZXR1cm4gZnVuY3Rpb24gKHRva2VucykgeyByZXR1cm4gdG9rZW5zLnNvbWUoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiByZS50ZXN0KHRva2VuKTsgfSk7IH07IH0pO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCkge1xuICAgIHZhciB0ZXJtcyA9IHRleHQucmVwbGFjZShFREdFX0NIQVJTLCAnJykubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW107XG4gICAgcmV0dXJuIHRlcm1zLm1hcChmdW5jdGlvbiAodGVybSkgeyByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQodGVybS5zbGljZSgwLCBNQVhfVEVSTV9MRU5HVEgpLnJlcGxhY2UoL1xcKi9nLCAnLionKSwgXCIkXCIpLCAnaScpOyB9KTtcbn1cbmZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XG4gICAgdmFyIHZhbHVlXzEsIHZhbHVlXzFfMTtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWNjZXNzLCBwYXJ0LCBlXzFfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYih2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCA2LCA3LCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZV8xID0gX19hc3luY1ZhbHVlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlXzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSA9IF9iLnNlbnQoKSwgIXZhbHVlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSB2YWx1ZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihwYXJ0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbNywgLCAxMCwgMTFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xICYmICF2YWx1ZV8xXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKHZhbHVlXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbMiAvKnJldHVybiovLCBzdWNjZXNzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0vLyBCTTI1IHNpbWlsYXJpdHkgY29uc3RhbnRzXG52YXIgQk0yNWsgPSAxLjI7XG5mdW5jdGlvbiBldmFsdWF0ZVNjb3JlKG5vZGUsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJTY29yZSwgYm9vc3QsIF9hLCBsZWZ0U2NvcmUsIHJpZ2h0U2NvcmUsIGxlZnRTY29yZSwgcmlnaHRTY29yZSwgcmVzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnT3BDYWxsJyAmJiBub2RlLm9wID09PSAnbWF0Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlLnR5cGUgPT09ICdGdW5jQ2FsbCcgJiYgbm9kZS5uYW1lID09PSAnYm9vc3QnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTY29yZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBib29zdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb3N0LnR5cGUgPT09ICdudW1iZXInICYmIGlubmVyU2NvcmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaW5uZXJTY29yZSArIGJvb3N0LmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9hID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdPcic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQW5kJzogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBsZWZ0U2NvcmUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0U2NvcmUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsZWZ0U2NvcmUgKyByaWdodFNjb3JlXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbGVmdFNjb3JlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICByaWdodFNjb3JlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsZWZ0U2NvcmUgKyByaWdodFNjb3JlXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKG5vZGUsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzLnR5cGUgPT09ICdib29sZWFuJyAmJiByZXMuZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dCwgcGF0dGVybiwgdG9rZW5zLCB0ZXJtcywgZGlkU3VjY2VlZCwgc2NvcmUsIF9sb29wXzEsIF9pLCB0ZXJtc18xLCByZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShsZWZ0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShyaWdodCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnYXRoZXJUZXh0KHRleHQsIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2F0aGVyVGV4dChwYXR0ZXJuLCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zID0gdGVybXMuY29uY2F0KG1hdGNoUGF0dGVyblJlZ2V4KHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGRpZFN1Y2NlZWQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRlcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uIChyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyZXEgPSB0b2tlbnMucmVkdWNlKGZ1bmN0aW9uIChjLCB0b2tlbikgeyByZXR1cm4gYyArIChyZS50ZXN0KHRva2VuKSA/IDEgOiAwKTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZSArPSAoZnJlcSAqIChCTTI1ayArIDEpKSAvIChmcmVxICsgQk0yNWspO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgdGVybXNfMSA9IHRlcm1zOyBfaSA8IHRlcm1zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZSA9IHRlcm1zXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShyZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNjb3JlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59ZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRleHRzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZS50eXBlID09PSAnb2JqZWN0JykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYmxvY2tUZXh0KHZhbHVlLmRhdGEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYXJyYXlUZXh0KHZhbHVlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0ZXh0cy5qb2luKCdcXG5cXG4nKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0KSB7XG4gICAgdmFyIHZhbHVlXzEsIHZhbHVlXzFfMTtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gW107IH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibG9jaywgdGV4dCwgZV8xXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVfMSA9IF9fYXN5bmNWYWx1ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZV8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8xXzEgPSBfYi5zZW50KCksICF2YWx1ZV8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBibG9jayA9IHZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmxvY2sudHlwZSA9PT0gJ29iamVjdCcpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGFycmF5VGV4dChibG9jaywgcmVzdWx0KV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xICYmICF2YWx1ZV8xXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbCh2YWx1ZV8xKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJsb2NrVGV4dChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjaGlsZHJlbl8xID0gY2hpbGRyZW47IF9pIDwgY2hpbGRyZW5fMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5fMVtfaV07XG4gICAgICAgIGlmIChjaGlsZCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkLl90eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgY2hpbGQuX3R5cGUgPT09ICdzcGFuJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkLnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQudGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufWZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICAgIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB2YWx1ZV8xID0gdmFsdWU7IF9pIDwgdmFsdWVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZhbHVlXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAodmFsdWUuX3JlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSBPYmplY3QudmFsdWVzKHZhbHVlKTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IF9iW19hXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgIC8vIEhpZ2ggc3Vycm9nYXRlLiBEb24ndCBjb3VudCB0aGlzLlxuICAgICAgICAgICAgLy8gQnkgb25seSBjb3VudGluZyB0aGUgbG93IHN1cnJvZ2F0ZSB3ZSB3aWxsIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBVVEYtOCBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbnZhciBnbG9iYWwgPSB7fTtcbmdsb2JhbC5hbnl3aGVyZSA9IGZ1bmN0aW9uIGFueXdoZXJlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmFueXdoZXJlLmFyaXR5ID0gMTtcbmdsb2JhbC5jb2FsZXNjZSA9IGZ1bmN0aW9uIGNvYWxlc2NlKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2ksIGFyZ3NfMSwgYXJnLCB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBhcmdzXzEgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGFyZ3NfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmcsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmNvdW50ID0gZnVuY3Rpb24gY291bnQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lciwgbnVtLCBpbm5lcl8xLCBpbm5lcl8xXzEsIGVfMV8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbm5lci5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBudW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyXzEgPSBfX2FzeW5jVmFsdWVzKGlubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgaW5uZXJfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJfMV8xID0gX2Iuc2VudCgpLCAhaW5uZXJfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lcl8xXzEgJiYgIWlubmVyXzFfMS5kb25lICYmIChfYSA9IGlubmVyXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGlubmVyXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIobnVtKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5nbG9iYWwuZGF0ZVRpbWUgPSBmdW5jdGlvbiBkYXRlVGltZShhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2YWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5kYXRlVGltZS5hcml0eSA9IDE7XG5nbG9iYWwuZGVmaW5lZCA9IGZ1bmN0aW9uIGRlZmluZWQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbm5lci50eXBlID09PSAnbnVsbCcgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuZ2xvYmFsLmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuaWRlbnRpdHkpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmlkZW50aXR5LmFyaXR5ID0gMDtcbmdsb2JhbC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lciwgbnVtLCBpbm5lcl8yLCBpbm5lcl8yXzEsIGVfMl8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlubmVyLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICBudW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyXzIgPSBfX2FzeW5jVmFsdWVzKGlubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgaW5uZXJfMi5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJfMl8xID0gX2Iuc2VudCgpLCAhaW5uZXJfMl8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lcl8yXzEgJiYgIWlubmVyXzJfMS5kb25lICYmIChfYSA9IGlubmVyXzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGlubmVyXzIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIobnVtKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwubGVuZ3RoLmFyaXR5ID0gMTtcbmdsb2JhbC5wYXRoID0gZnVuY3Rpb24gcGF0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21QYXRoKG5ldyBQYXRoKGlubmVyLmRhdGEpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbmdsb2JhbC5zdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyhcIlwiLmNvbmNhdCh2YWx1ZS5kYXRhKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbmdsb2JhbC5yZWZlcmVuY2VzID0gZnVuY3Rpb24gcmVmZXJlbmNlcyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzMsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGhTZXQsIF9pLCBhcmdzXzIsIGFyZywgcGF0aCwgcGF0aF8xLCBwYXRoXzFfMSwgZWxlbSwgZV8zXzEsIHNjb3BlVmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHBhdGhTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYXJnc18yID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBhcmdzXzIubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzXzJbX2ldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZywgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhdGgudHlwZSA9PT0gJ3N0cmluZycpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aFNldC5hZGQocGF0aC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzQsIDksIDEwLCAxNV0pO1xuICAgICAgICAgICAgICAgICAgICBwYXRoXzEgPSAoZV8zID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKHBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgcGF0aF8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXRoXzFfMSA9IF9iLnNlbnQoKSwgIXBhdGhfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHBhdGhfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGVfM18xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzMgPSB7IGVycm9yOiBlXzNfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxMCwgLCAxMywgMTRdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGF0aF8xXzEgJiYgIXBhdGhfMV8xLmRvbmUgJiYgKF9hID0gcGF0aF8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChwYXRoXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTI7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoU2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2NvcGUudmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwucmVmZXJlbmNlcy5hcml0eSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID49IDE7IH07XG5nbG9iYWwucm91bmQgPSBmdW5jdGlvbiByb3VuZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlLCBudW0sIHByZWMsIHByZWNWYWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG51bSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcmdzLmxlbmd0aCA9PT0gMikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwcmVjVmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gJ251bWJlcicgfHwgcHJlY1ZhbHVlLmRhdGEgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHByZWNWYWx1ZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSmF2YVNjcmlwdCdzIHJvdW5kKCkgZnVuY3Rpb24gd2lsbCBhbHdheXMgcm91bmRzIHRvd2FyZHMgcG9zaXRpdmUgaW5maW5pdHkgKC0zLjUgLT4gLTMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBiZWhhdmlvciB3ZSdyZSBpbnRlcmVzdGVkIGluIGlzIHRvIFwicm91bmQgaGFsZiBhd2F5IGZyb20gemVyb1wiLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihNYXRoLnJvdW5kKG51bSkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5yb3VuZC5hcml0eSA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gY291bnQgPj0gMSAmJiBjb3VudCA8PSAyOyB9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbmdsb2JhbC5ub3cgPSBmdW5jdGlvbiBub3coYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQudGltZXN0YW1wLnRvSVNPU3RyaW5nKCkpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuZ2xvYmFsLmJvb3N0ID0gZnVuY3Rpb24gYm9vc3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBzY29yaW5nIGZ1bmN0aW9uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGJvb3N0IGNhbGwnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbnZhciBzdHJpbmcgPSB7fTtcbnN0cmluZy5sb3dlciA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbnN0cmluZy5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcudXBwZXIgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5zdHJpbmcudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nLnNwbGl0ID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyLCBzZXA7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoW10pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHVzZXMgYSBVbmljb2RlIGNvZGVwb2ludCBzcGxpdHRpbmcgYWxnb3JpdGhtXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKEFycmF5LmZyb20oc3RyLmRhdGEpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhzdHIuZGF0YS5zcGxpdChzZXAuZGF0YSkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuc3RyaW5nLnNwbGl0LmFyaXR5ID0gMjtcbmdsb2JhbC5sb3dlciA9IHN0cmluZy5sb3dlcjtcbmdsb2JhbC51cHBlciA9IHN0cmluZy51cHBlcjtcbnN0cmluZy5zdGFydHNXaXRoID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyLCBwcmVmaXg7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzdHIuZGF0YS5zdGFydHNXaXRoKHByZWZpeC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbnN0cmluZy5zdGFydHNXaXRoLmFyaXR5ID0gMjtcbnZhciBhcnJheSA9IHt9O1xuYXJyYXkuam9pbiA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzQsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyciwgc2VwLCBidWYsIG5lZWRTZXAsIGFycl8xLCBhcnJfMV8xLCBlbGVtLCBlXzRfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBzZXAgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXAudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWYgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbmVlZFNlcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzMsIDgsIDksIDE0XSk7XG4gICAgICAgICAgICAgICAgICAgIGFycl8xID0gX19hc3luY1ZhbHVlcyhhcnIpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBhcnJfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzFfMSA9IF9iLnNlbnQoKSwgIWFycl8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gYXJyXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRTZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiArPSBzZXAuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsZW0udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWYgKz0gXCJcIi5jb25jYXQoZWxlbS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5lZWRTZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGVfNF8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzQgPSB7IGVycm9yOiBlXzRfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzksICwgMTIsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFycl8xXzEgJiYgIWFycl8xXzEuZG9uZSAmJiAoX2EgPSBhcnJfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoYXJyXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTE7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoYnVmKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmFycmF5LmpvaW4uYXJpdHkgPSAyO1xuYXJyYXkuY29tcGFjdCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFycjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycl8yLCBhcnJfMl8xLCBlbGVtLCBlXzVfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfNSwgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyXzIgPSBfX2FzeW5jVmFsdWVzKGFycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoYXJyXzIubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfMl8xID0gX2Iuc2VudCgpLCAhYXJyXzJfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBhcnJfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbGVtLnR5cGUgIT09ICdudWxsJykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGVsZW0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV81XzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzJfMSAmJiAhYXJyXzJfMS5kb25lICYmIChfYSA9IGFycl8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKGFycl8yKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5hcnJheS5jb21wYWN0LmFyaXR5ID0gMTtcbmFycmF5LnVuaXF1ZSA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGVkLCB2YWx1ZV8yLCB2YWx1ZV8yXzEsIGl0ZXIsIF9hLCBlXzZfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfNiwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEsIDEzLCAxNCwgMTldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVfMiA9IF9fYXN5bmNWYWx1ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlXzIubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8yXzEgPSBfYy5zZW50KCksICF2YWx1ZV8yXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlciA9IHZhbHVlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBpdGVyLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzogcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkYXRldGltZSc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhYWRkZWQuaGFzKGl0ZXIuZGF0YSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZC5hZGQoaXRlci5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChpdGVyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGl0ZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzZfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV82ID0geyBlcnJvcjogZV82XzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMTQsICwgMTcsIDE4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzJfMSAmJiAhdmFsdWVfMl8xLmRvbmUgJiYgKF9iID0gdmFsdWVfMltcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2IuY2FsbCh2YWx1ZV8yKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuYXJyYXkudW5pcXVlLmFyaXR5ID0gMTtcbnZhciBwdCA9IHt9O1xucHQudGV4dCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlLCB0ZXh0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyh0ZXh0KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbnB0LnRleHQuYXJpdHkgPSAxO1xudmFyIHNhbml0eSA9IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbnNhbml0eS5wcm9qZWN0SWQgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LnByb2plY3RJZCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuc2FuaXR5LmRhdGFzZXQgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xudmFyIHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBmdW5jdGlvbiBvcmRlcihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBiYXNlXzEsIGJhc2VfMV8xO1xuICAgIHZhciBlXzcsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcHBlcnMsIGRpcmVjdGlvbnMsIG4sIF9pLCBhcmdzXzMsIG1hcHBlciwgZGlyZWN0aW9uLCBhdXgsIGlkeCwgdmFsdWUsIG5ld1Njb3BlLCB0dXBsZSwgaSwgcmVzdWx0LCBfYiwgX2MsIGVfN18xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vcnBldHJpY2gvYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1hc3luYy10by1wcm9taXNlcy9pc3N1ZXMvNTlcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vcnBldHJpY2gvYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1hc3luYy10by1wcm9taXNlcy9pc3N1ZXMvNTlcbiAgICAgICAgICAgICAgICAgICAgX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2UuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFwcGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgYXJnc18zID0gYXJnczsgX2kgPCBhcmdzXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXIgPSBhcmdzXzNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2FzYyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVyLnR5cGUgPT09ICdEZXNjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdkZXNjJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBlci50eXBlID09PSAnQXNjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdXggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFsyLCAxMywgMTQsIDE5XSk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VfMSA9IF9fYXN5bmNWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8xXzEgPSBfZC5zZW50KCksICFiYXNlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHR1cGxlID0gW19kLnNlbnQoKSwgaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBuKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gKF9iID0gdHVwbGUpLnB1c2g7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3VsdC5nZXQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYy5hcHBseShfYiwgW19kLnNlbnQoKV0pO1xuICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGF1eC5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMTE7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGVfN18xID0gX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzcgPSB7IGVycm9yOiBlXzdfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFsxNCwgLCAxNywgMThdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8xXzEgJiYgIWJhc2VfMV8xLmRvbmUgJiYgKF9hID0gYmFzZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChiYXNlXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMTY7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgIGF1eC5zb3J0KGZ1bmN0aW9uIChhVHVwbGUsIGJUdXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1tpXSA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAtYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gc29ydGluZyBvbiB0aGUgb3JpZ2luYWwgaW5kZXggZm9yIHN0YWJsZSBzb3J0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoYXV4Lm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdlswXTsgfSkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gY291bnQgPj0gMTsgfTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG5waXBlRnVuY3Rpb25zLnNjb3JlID0gZnVuY3Rpb24gc2NvcmUoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgYmFzZV8yLCBiYXNlXzJfMTtcbiAgICB2YXIgZV84LCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bmtub3duLCBzY29yZWQsIHZhbHVlLCBfYiwgX2MsIG5ld1Njb3BlLCB2YWx1ZVNjb3JlLCBfaSwgYXJnc180LCBhcmcsIF9kLCBuZXdPYmplY3QsIGVfOF8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2UuaXNBcnJheSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbnl0aGluZyB0aGF0IGlzbid0IGFuIG9iamVjdCBzaG91bGQgYmUgc29ydGVkIGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93biA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzY29yZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2UudHJ5cy5wdXNoKFsxLCAxMiwgMTMsIDE4XSk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VfMiA9IF9fYXN5bmNWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VfMi5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8yXzEgPSBfZS5zZW50KCksICFiYXNlXzJfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZS50eXBlICE9PSAnb2JqZWN0JykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBfYyA9IChfYiA9IHVua25vd24pLnB1c2g7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF9jLmFwcGx5KF9iLCBbX2Uuc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PT0gJ251bWJlcicgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYXJnc180ID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBhcmdzXzQubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NfNFtfaV07XG4gICAgICAgICAgICAgICAgICAgIF9kID0gdmFsdWVTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShhcmcsIG5ld1Njb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNjb3JlID0gX2QgKyBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gODtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUuZGF0YSwgeyBfc2NvcmU6IHZhbHVlU2NvcmUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGVfOF8xID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzggPSB7IGVycm9yOiBlXzhfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgX2UudHJ5cy5wdXNoKFsxMywgLCAxNiwgMTddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8yXzEgJiYgIWJhc2VfMl8xLmRvbmUgJiYgKF9hID0gYmFzZV8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChiYXNlXzIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTU7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzgpIHRocm93IGVfOC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLl9zY29yZSAtIGEuX3Njb3JlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhzY29yZWQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gY291bnQgPj0gMTsgfTtcbnZhciBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzQmVmb3JlLCBoYXNBZnRlcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaGFzQmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgIT09IG51bGw7XG4gICAgICAgICAgICBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzQmVmb3JlICYmIGhhc0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoJ3VwZGF0ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNBZnRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKCdjcmVhdGUnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoJ2RlbGV0ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gJ2RlbHRhJztcbmRlbHRhLmNoYW5nZWRPbmx5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZGVsdGEuY2hhbmdlZE9ubHkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZE9ubHkubW9kZSA9ICdkZWx0YSc7XG52YXIgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbnZhciBtYXRoID0ge307XG5tYXRoLm1pbiA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzksIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyciwgbiwgYXJyXzMsIGFycl8zXzEsIGVsZW0sIGVfOV8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMiwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyXzMgPSBfX2FzeW5jVmFsdWVzKGFycik7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGFycl8zLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfM18xID0gX2Iuc2VudCgpLCAhYXJyXzNfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBhcnJfM18xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnbnVsbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0udHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobiA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uZGF0YSA8IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBlbGVtLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzlfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV85ID0geyBlcnJvcjogZV85XzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfM18xICYmICFhcnJfM18xLmRvbmUgJiYgKF9hID0gYXJyXzNbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGFycl8zKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzkpIHRocm93IGVfOS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMobildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5tYXRoLm1pbi5hcml0eSA9IDE7XG5tYXRoLm1heCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzEwLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIsIG4sIGFycl80LCBhcnJfNF8xLCBlbGVtLCBlXzEwXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnIuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICBhcnJfNCA9IF9fYXN5bmNWYWx1ZXMoYXJyKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgYXJyXzQubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFycl80XzEgPSBfYi5zZW50KCksICFhcnJfNF8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGFycl80XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudWxsJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgZWxlbS5kYXRhID4gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGVsZW0uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGVfMTBfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8xMCA9IHsgZXJyb3I6IGVfMTBfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFycl80XzEgJiYgIWFycl80XzEuZG9uZSAmJiAoX2EgPSBhcnJfNFtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoYXJyXzQpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMTApIHRocm93IGVfMTAuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKG4pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xubWF0aC5tYXguYXJpdHkgPSAxO1xubWF0aC5zdW0gPSBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgZV8xMSwgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyLCBuLCBhcnJfNSwgYXJyXzVfMSwgZWxlbSwgZV8xMV8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGFycl81ID0gX19hc3luY1ZhbHVlcyhhcnIpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBhcnJfNS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzVfMSA9IF9iLnNlbnQoKSwgIWFycl81XzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gYXJyXzVfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gJ251bGwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiArPSBlbGVtLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgZV8xMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzExID0geyBlcnJvcjogZV8xMV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzVfMSAmJiAhYXJyXzVfMS5kb25lICYmIChfYSA9IGFycl81W1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChhcnJfNSldO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xMSkgdGhyb3cgZV8xMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMobildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5tYXRoLnN1bS5hcml0eSA9IDE7XG5tYXRoLmF2ZyA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzEyLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIsIG4sIGMsIGFycl82LCBhcnJfNl8xLCBlbGVtLCBlXzEyXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnIuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGFycl82ID0gX19hc3luY1ZhbHVlcyhhcnIpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBhcnJfNi5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzZfMSA9IF9iLnNlbnQoKSwgIWFycl82XzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gYXJyXzZfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gJ251bGwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiArPSBlbGVtLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzEyXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMTIgPSB7IGVycm9yOiBlXzEyXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfNl8xICYmICFhcnJfNl8xLmRvbmUgJiYgKF9hID0gYXJyXzZbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGFycl82KV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzEyKSB0aHJvdyBlXzEyLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKG4gLyBjKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbm1hdGguYXZnLmFyaXR5ID0gMTtcbnZhciBuYW1lc3BhY2VzID0ge1xuICAgIGdsb2JhbDogZ2xvYmFsLFxuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIGFycmF5OiBhcnJheSxcbiAgICBwdDogcHQsXG4gICAgZGVsdGE6IGRlbHRhLFxuICAgIGRpZmY6IGRpZmYsXG4gICAgc2FuaXR5OiBzYW5pdHksXG4gICAgbWF0aDogbWF0aFxufTtjb25zdCBXUyA9IC9eKFtcXHRcXG5cXHZcXGZcXHIgXFx1MDA4NVxcdTAwQTBdfChcXC9cXC9bXlxcbl0qXFxuKSkrLztcbmNvbnN0IE5VTSA9IC9eXFxkKy87XG5jb25zdCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5cbi8vIFByZWNlZGVuY2UgbGV2ZWxzIGZvciBiaW5hcnkgb3BlcmF0b3JzOlxuY29uc3QgUFJFQ19QQUlSID0gMTtcbmNvbnN0IFBSRUNfT1IgPSAyO1xuY29uc3QgUFJFQ19BTkQgPSAzO1xuY29uc3QgUFJFQ19DT01QID0gNDtcbmNvbnN0IFBSRUNfT1JERVIgPSA0O1xuY29uc3QgUFJFQ19BREQgPSA2O1xuY29uc3QgUFJFQ19TVUIgPSA2O1xuY29uc3QgUFJFQ19NVUwgPSA3O1xuY29uc3QgUFJFQ19ESVYgPSA3O1xuY29uc3QgUFJFQ19NT0QgPSA3O1xuY29uc3QgUFJFQ19QT1cgPSA4O1xuXG4vLyBQcmVjZWRlbmNlIGxldmVscyBmb3IgcHJlZml4IG9wZXJhdG9yczpcbmNvbnN0IFBSRUNfUE9TID0gMTA7XG5jb25zdCBQUkVDX05PVCA9IDEwO1xuY29uc3QgUFJFQ19ORUcgPSA4O1xuXG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cbiAgZGVsZXRlIHJlc3VsdC5wb3NpdGlvbjtcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByKHN0ciwgcG9zLCBsZXZlbCkge1xuICAvLyBJbiB0aGlzIGZ1bmN0aW9uIHdlIHBhcnNlIHByZWNlZGVuY2UgXCJtYW51YWxseVwiIGJ5IGhhdmluZyB0d28gdmFyaWFibGVzOlxuICAvL1xuICAvLyBgbGV2ZWxgIGlzIHRoZSBtaW5pbXVtIHByZWNlZGVuY2UgbGV2ZWwgd2Ugd2FudCB0byBwYXJzZSBhdC4gSWYgdGhpcyBpc1xuICAvLyBlLmcuIDcgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IHBhcnNlIGAzICsgNGAgKHNpbmNlIGFkZGl0aW9uIGlzIGF0IDYpLFxuICAvLyBidXQgaW5zdGVhZCBqdXN0IHJldHVybiBgMWAgYW5kIGxlYXZlIGAgKyA1YCByZW1haW5pbmcuIFdlIHVzZSB0aGlzIHNvIHRoYXRcbiAgLy8gd2hpbGUgaGFuZGxpbmcgdGhlIFJIUyBvZiB0aGUgbXVsdGlwbGljYXRpb24gaW4gYDEgKyAyICogMyArIDRgIHdlIG9ubHkgcGFyc2UgYDNgLlxuICAvL1xuICAvLyBgbGhzTGV2ZWxgIGlzIHRoZSBwcmVjZWRlbmNlIGxldmVsIG9mIHRoZSBjdXJyZW50bHkgcGFyc2VkIGV4cHJlc3Npb24gb25cbiAgLy8gdGhlIGxlZnQtaGFuZCBzaWRlLiBUaGlzIGlzIG1haW5seSB1c2VkIHRvIGhhbmRsZSBub24tYXNzb2NpY2F0aXZlbmVzcy5cblxuICAvLyBUaGlzIG1lYW5zIHRoYXQgeW91J2xsIHNlZSBjb2RlIGxpa2U6XG4gIC8vIC0gYGlmIChsZXZlbCA+IFBSRUNfWFhYKSBicmVha2A6IE9wZXJhdG9yIGlzIGF0IHRoaXMgcHJlY2VkZW5jZSBsZXZlbC5cbiAgLy8gLSBgaWYgKGxoc0xldmVsIDwgUFJFQ19YWFgpIGJyZWFrYDogT3BlcmF0b3IgaXMgbGVmdC1hc3NvY2lhdGl2ZS5cbiAgLy8gLSBgaWYgKGxoc0xldmVsIDw9IFBSRUNfWFhYKSBicmVha2A6IE9wZXJhdG9yIGlzIHJpZ2h0L25vbi1hc3NvY2lhdGl2ZS5cbiAgLy8gLSBgcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX1hYWCArIDEpYDogT3BlcmF0b3IgaXMgbGVmdC9ub24tYXNzb2ljYXRlLlxuICAvLyAtIGBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfWFhYKWA6IE9wZXJhdG9yIGlzIHJpZ2h0LWFzc29pY2F0ZS5cblxuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBsZXQgbWFya3M7XG5cbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgJysnOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfUE9TKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgbWFya3MgPSBbe25hbWU6ICdwb3MnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJy0nOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTkVHKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgbWFya3MgPSBbe25hbWU6ICduZWcnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJygnOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlICcsJzoge1xuICAgICAgICAgIC8vIFR1cGxlc1xuICAgICAgICAgIG1hcmtzID0gW3tuYW1lOiAndHVwbGUnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJyknKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3R1cGxlX2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJyknOiB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MgPSBbe25hbWU6ICdncm91cCcsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICchJzoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX05PVCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAnbm90JywgcG9zaXRpb246IHN0YXJ0UG9zfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICd7Jzoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdbJzpcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAnYXJyYXknLCBwb3NpdGlvbjogcG9zfV07XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcblxuICAgICAgaWYgKHN0cltwb3NdICE9PSAnXScpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09ICcuLi4nKSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnYXJyYXlfc3BsYXQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXNcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJlcy5wb3NpdGlvbjtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJ10nKSBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gJ10nKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnYXJyYXlfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ14nOiB7XG4gICAgICBwb3MrKztcbiAgICAgIG1hcmtzID0gW107XG4gICAgICB3aGlsZSAoc3RyW3Bvc10gPT09ICcuJyAmJiBzdHJbcG9zICsgMV0gPT09ICdeJykge1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnZGJscGFyZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3BhcmVudCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnQCc6XG4gICAgICBtYXJrcyA9IFt7bmFtZTogJ3RoaXMnLCBwb3NpdGlvbjogc3RhcnRQb3N9XTtcbiAgICAgIHBvcysrO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICcqJzpcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAnZXZlcnl0aGluZycsIHBvc2l0aW9uOiBzdGFydFBvc31dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVha1xuICAgIGNhc2UgJyQnOiB7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSAxICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHtuYW1lOiAncGFyYW0nLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxfSxcbiAgICAgICAgICB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gJ2ludGVnZXInO1xuXG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJy4nKSB7XG4gICAgICAgICAgbGV0IGZyYWNMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgTlVNKTtcbiAgICAgICAgICBpZiAoZnJhY0xlbikge1xuICAgICAgICAgICAgbmFtZSA9ICdmbG9hdCc7XG4gICAgICAgICAgICBwb3MgKz0gMSArIGZyYWNMZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSAnZScgfHwgc3RyW3Bvc10gPT09ICdFJykge1xuICAgICAgICAgIG5hbWUgPSAnc2NpJztcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICcrJyB8fCBzdHJbcG9zXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgaWYgKCFleHBMZW4pIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAge25hbWUsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAge25hbWU6IG5hbWUgKyAnX2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICBdO1xuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBwb3MgKz0gaWRlbnRMZW47XG4gICAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICBjYXNlICcoJzoge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICAgICAge25hbWU6ICd0aGlzX2F0dHInLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgICAgICB7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICAgICAge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICB9XG5cbiAgbGV0IGxoc0xldmVsID0gMTI7XG4gIGxldCB0cmF2O1xuXG4gIGxvb3A6IHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IGlubmVyUG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoaW5uZXJQb3MgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyk7XG4gICAgaWYgKHRyYXYudHlwZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAndHJhdmVyc2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgIHdoaWxlICh0cmF2LnR5cGUgPT09ICdzdWNjZXNzJykge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKTtcbiAgICAgICAgcG9zID0gdHJhdi5wb3NpdGlvbjtcbiAgICAgICAgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgc2tpcFdTKHN0ciwgcG9zKSk7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndHJhdmVyc2FsX2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgbGV0IHRva2VuID0gc3RyW2lubmVyUG9zXTtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICc9Jzoge1xuICAgICAgICBsZXQgbmV4dFRva2VuID0gc3RyW2lubmVyUG9zICsgMV07XG4gICAgICAgIHN3aXRjaCAobmV4dFRva2VuKSB7XG4gICAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIC8vID0+XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BBSVIgfHwgbGhzTGV2ZWwgPD0gUFJFQ19QQUlSKSBicmVhayBsb29wXG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QQUlSKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdwYWlyJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUEFJUjtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJz0nOiB7XG4gICAgICAgICAgICAvLyA9PVxuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDUpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29wJywgcG9zaXRpb246IGlubmVyUG9zfSwge25hbWU6ICdvcF9lbmQnLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyfSk7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICcrJzoge1xuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKSBicmVhayBsb29wXG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ2FkZCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICctJzoge1xuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKSBicmVhayBsb29wXG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ3N1YicsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICcqJzoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09ICcqJykge1xuICAgICAgICAgIC8vICoqXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19QT1cgfHwgbGhzTGV2ZWwgPD0gUFJFQ19QT1cpIGJyZWFrIGxvb3BcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ3BvdycsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUE9XO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyAqXG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTVVMIHx8IGxoc0xldmVsIDwgUFJFQ19NVUwpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTVVMICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnbXVsJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01VTDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJy8nOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfRElWIHx8IGxoc0xldmVsIDwgUFJFQ19ESVYpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfRElWICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnZGl2JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0RJVjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyUnOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTU9EIHx8IGxoc0xldmVsIDwgUFJFQ19NT0QpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTU9EICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnbW9kJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01PRDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgaWYgKHN0cltuZXh0UG9zXSA9PT0gJz0nKSB7XG4gICAgICAgICAgbmV4dFBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBuZXh0UG9zfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICd8Jzoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09ICd8Jykge1xuICAgICAgICAgIC8vIHx8XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1IpIGJyZWFrIGxvb3BcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19PUiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ29yJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiAxMSB8fCBsaHNMZXZlbCA8IDExKSBicmVhayBsb29wXG4gICAgICAgICAgLy8gcGlwZSBjYWxsXG4gICAgICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKTtcbiAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICBpZiAoIWlkZW50TGVuKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBpZGVudFBvc31cbiAgICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJygnIHx8IHN0cltwb3NdID09PSAnOicpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAncGlwZWNhbGwnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICcmJzoge1xuICAgICAgICAvLyAmJlxuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gJyYnKSBicmVhayBsb29wXG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQU5EICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnYW5kJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FORDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyEnOiB7XG4gICAgICAgIC8vICE9XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gJz0nKSBicmVhayBsb29wXG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDJ9KTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2QnOiB7XG4gICAgICAgIC8vIGFzY1xuICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDQpICE9PSAnZGVzYycpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpIGJyZWFrIGxvb3BcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ2Rlc2MnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gaW5uZXJQb3MgKyA0O1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdhJzoge1xuICAgICAgICAvLyBhc2NcbiAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gJ2FzYycpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpIGJyZWFrIGxvb3BcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ2FzYycsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSBpbm5lclBvcyArIDM7XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19PUkRFUjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbGV0IGlkZW50ID0gcGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCk7XG4gICAgICAgIHN3aXRjaCAoaWRlbnQpIHtcbiAgICAgICAgICBjYXNlICdpbic6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApIGJyZWFrIGxvb3BcblxuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcblxuICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgaXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICcuJyAmJiBzdHJbcG9zICsgMV0gPT09ICcuJykge1xuICAgICAgICAgICAgICAvLyBMSFMgaW4gUkFOR0VcbiAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaW5jX3JhbmdlJztcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdleGNfcmFuZ2UnO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnaW5fcmFuZ2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoe25hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvc30sIHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTEhTIGluIFJIU1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDJ9KTtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnKScpIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbWF0Y2gnOiB7XG4gICAgICAgICAgICAvLyBtYXRjaCBvcGVyYXRvclxuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29wJywgcG9zaXRpb246IGlubmVyUG9zfSwge25hbWU6ICdvcF9lbmQnLCBwb3NpdGlvbjogaW5uZXJQb3MgKyA1fSk7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBmYWlsUG9zaXRpb24gPSB0cmF2Py50eXBlID09PSAnZXJyb3InICYmIHRyYXYucG9zaXRpb247XG5cbiAgcmV0dXJuIHt0eXBlOiAnc3VjY2VzcycsIG1hcmtzLCBwb3NpdGlvbjogcG9zLCBmYWlsUG9zaXRpb259XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhdmVyc2FsKHN0ciwgcG9zKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgIGNhc2UgJy4nOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKCFpZGVudExlbikgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgcG9zICs9IGlkZW50TGVuO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAge25hbWU6ICdhdHRyX2FjY2VzcycsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBpZGVudFN0YXJ0fSxcbiAgICAgICAgICB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICBdLFxuICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgfVxuICAgIH1cbiAgICBjYXNlICctJzpcbiAgICAgIGlmIChzdHJbcG9zICsgMV0gIT09ICc+JykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgLy8gLT5cblxuICAgICAgbGV0IG1hcmtzID0gW3tuYW1lOiAnZGVyZWYnLCBwb3NpdGlvbjogc3RhcnRQb3N9XTtcbiAgICAgIHBvcyArPSAyO1xuXG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MucHVzaChcbiAgICAgICAgICB7bmFtZTogJ2RlcmVmX2F0dHInLCBwb3NpdGlvbjogaWRlbnRQb3N9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogaWRlbnRQb3N9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICBtYXJrcyxcbiAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgIH1cbiAgICBjYXNlICdbJzoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG5cbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gJ10nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgIG1hcmtzOiBbe25hbWU6ICdhcnJheV9wb3N0Zml4JywgcG9zaXRpb246IHN0YXJ0UG9zfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDEsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHJhbmdlUG9zID0gcG9zO1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcblxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcblxuICAgICAgaWYgKHN0cltwb3NdID09PSAnLicgJiYgc3RyW3BvcyArIDFdID09PSAnLicpIHtcbiAgICAgICAgbGV0IHR5cGUgPSAnaW5jX3JhbmdlJztcbiAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgdHlwZSA9ICdleGNfcmFuZ2UnO1xuICAgICAgICAgIHBvcyArPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICBpZiAoc3RyW3Bvc10gIT09ICddJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3NsaWNlJywgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICAgIHtuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3N9LFxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyW3Bvc10gIT09ICddJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgIG1hcmtzOiBbe25hbWU6ICdzcXVhcmVfYnJhY2tldCcsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMSxcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSAnfCc6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSAneycpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHtuYW1lOiAncHJvamVjdGlvbicsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICd7Jzoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoe25hbWU6ICdwcm9qZWN0aW9uJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxufVxuXG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xuICBsZXQgbWFya3MgPSBbXTtcblxuICBtYXJrcy5wdXNoKHtuYW1lOiAnZnVuY19jYWxsJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG5cbiAgaWYgKHN0cltwb3NdID09PSAnOicgJiYgc3RyW3BvcyArIDFdID09PSAnOicpIHtcbiAgICBtYXJrcy5wdXNoKHtuYW1lOiAnbmFtZXNwYWNlJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgbWFya3MucHVzaCh7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSwge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgbWFya3MucHVzaCh7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHBvc30sIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvcyArIG5hbWVMZW59KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09ICcoJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIG1hcmtzLnB1c2goe25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBzdGFydFBvc30sIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG5cbiAgbGV0IGxhc3RQb3MgPSBwb3M7XG5cbiAgaWYgKHN0cltwb3NdICE9PSAnKScpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICBsYXN0UG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAvLyBBbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hc1xuICAgICAgaWYgKHN0cltwb3NdID09PSAnKScpIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cltwb3NdICE9PSAnKScpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cblxuICAvLyBOT1RFOiBhIGJpdCBhcmJpdHJhcnkgdGhlIGZ1bmNfYXJnc19lbmQgcG9pbnRzIGNvbWVzIGJlZm9yZSB0aGUgd2hpdGVzcGFjZS5cbiAgbWFya3MucHVzaCh7bmFtZTogJ2Z1bmNfYXJnc19lbmQnLCBwb3NpdGlvbjogbGFzdFBvc30pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7bmFtZTogJ29iamVjdCcsIHBvc2l0aW9uOiBwb3N9XTtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG5cbiAgd2hpbGUgKHN0cltwb3NdICE9PSAnfScpIHtcbiAgICBsZXQgcGFpclBvcyA9IHBvcztcblxuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gJy4uLicpIHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSAnfScgJiYgc3RyW3Bvc10gIT09ICcsJykge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiBleHByXG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3Rfc3BsYXQnLCBwb3NpdGlvbjogcGFpclBvc30pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3Rfc3BsYXRfdGhpcycsIHBvc2l0aW9uOiBwYWlyUG9zfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChleHByLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiBleHByXG4gICAgICBsZXQgbmV4dFBvcyA9IHNraXBXUyhzdHIsIGV4cHIucG9zaXRpb24pO1xuICAgICAgaWYgKGV4cHIubWFya3NbMF0ubmFtZSA9PT0gJ3N0cicgJiYgc3RyW25leHRQb3NdID09PSAnOicpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiB2YWx1ZVxuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb2JqZWN0X3BhaXInLCBwb3NpdGlvbjogcGFpclBvc30pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzLCB2YWx1ZS5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHZhbHVlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoe25hbWU6ICdvYmplY3RfZXhwcicsIHBvc2l0aW9uOiBwb3N9LCBleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09ICcsJykgYnJlYWtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuXG4gIGlmIChzdHJbcG9zXSAhPT0gJ30nKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICB9XG5cbiAgcG9zKys7XG4gIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3RfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICByZXR1cm4ge3R5cGU6ICdzdWNjZXNzJywgbWFya3MsIHBvc2l0aW9uOiBwb3N9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7bmFtZTogJ3N0cicsIHBvc2l0aW9uOiBwb3N9XTtcbiAgc3RyOiBmb3IgKDsgOyBwb3MrKykge1xuICAgIGlmIChwb3MgPiBzdHIubGVuZ3RoKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG5cbiAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICBjYXNlIHRva2VuOiB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzdHJfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICBwb3MrKztcbiAgICAgICAgYnJlYWsgc3RyXG4gICAgICB9XG4gICAgICBjYXNlICdcXFxcJzoge1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnc3RyX3BhdXNlJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICBpZiAoc3RyW3BvcyArIDFdID09PSAndScpIHtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSAneycpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICd1bmljb2RlX2hleCcsIHBvc2l0aW9uOiBwb3MgKyAzfSk7XG4gICAgICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZignfScsIHBvcyArIDMpO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4X2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4JywgcG9zaXRpb246IHBvcyArIDJ9KTtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICd1bmljb2RlX2hleF9lbmQnLCBwb3NpdGlvbjogcG9zICsgNn0pO1xuICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzaW5nbGVfZXNjYXBlJywgcG9zaXRpb246IHBvcyArIDF9KTtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnc3RyX3N0YXJ0JywgcG9zaXRpb246IHBvcyArIDF9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3R5cGU6ICdzdWNjZXNzJywgbWFya3MsIHBvc2l0aW9uOiBwb3N9XG59XG5cbmZ1bmN0aW9uIHNraXBXUyhzdHIsIHBvcykge1xuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpXG59XG5cbi8qKlxuICogUGFyc2VzIGEgcmVnZXggYXQgYSBwb3NpdGlvbiBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3YXMgbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VSZWdleChzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDBcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSByZWdleCBhdCBhIHBvc2l0aW9uIGFuZCByZXR1cm5zIG1hdGNoZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsXG59LyoqXG4gKiBKb2luIGNvbWJpbmVzIHR3byB0cmF2ZXJzYWxzLCByZXR1cm5pbmcgYSBtYXBwZXIgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBmaXJzdFxuICogYXBwbHlpbmcgYGFgIGFuZCB0aGVuIGFwcGx5aW5nIGBiYC5cbiAqL1xuZnVuY3Rpb24gam9pbihhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiBiKGEoYmFzZSkpOyB9O1xufVxuLyoqXG4gKiBNYXAgcmV0dXJucyBhIG5ldyBtYXBwZXIgd2hpY2ggd2lsbCB0aGUgaW5uZXIgbWFwcGUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gbWFwKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnTWFwJywgYmFzZTogYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiAnVGhpcycgfSkgfSk7IH07XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnRmxhdE1hcCcsIGJhc2U6IGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogJ1RoaXMnIH0pIH0pOyB9O1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgIGJ1aWxkOiBidWlsZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYS1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYi1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUGxhaW4obWFwcGVyLCByaWdodCkge1xuICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgYnVpbGQ6IG1hcHBlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYS1hJzpcbiAgICAgICAgY2FzZSAnYi1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ItYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2EtYic6XG4gICAgICAgIGNhc2UgJ2ItYic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlRWxlbWVudChtYXBwZXIsIHJpZ2h0KSB7XG4gICAgaWYgKCFyaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICBidWlsZDogbWFwcGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgICAgICBjYXNlICdhLWEnOlxuICAgICAgICBjYXNlICdiLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgY2FzZSAnYi1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYi1iJyxcbiAgICAgICAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2EtYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2EtYic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWInLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ItYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYi1iJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgICB9XG59dmFyIGlzRXF1YWwgPSBlcXVhbGl0eTtcbmZ1bmN0aW9uIGVxdWFsaXR5KGEsIGIpIHtcbiAgICBpZiAoKGEudHlwZSA9PT0gJ3N0cmluZycgJiYgYi50eXBlID09PSAnc3RyaW5nJykgfHxcbiAgICAgICAgKGEudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGIudHlwZSA9PT0gJ2Jvb2xlYW4nKSB8fFxuICAgICAgICAoYS50eXBlID09PSAnbnVsbCcgJiYgYi50eXBlID09PSAnbnVsbCcpIHx8XG4gICAgICAgIChhLnR5cGUgPT09ICdudW1iZXInICYmIGIudHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHJldHVybiBhLmRhdGEgPT09IGIuZGF0YTtcbiAgICB9XG4gICAgaWYgKGEudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiBiLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgcmV0dXJuIGEuZGF0YS5lcXVhbHMoYi5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufXZhciBvcGVyYXRvcnMgPSB7XG4gICAgJz09JzogZnVuY3Rpb24gZXEobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgJyE9JzogZnVuY3Rpb24gbmVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgICB9LFxuICAgICc+JzogZnVuY3Rpb24gZ3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ3N0cmVhbScgfHwgcmlnaHQudHlwZSA9PT0gJ3N0cmVhbScpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgJz49JzogZnVuY3Rpb24gZ3RlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJlYW0nIHx8IHJpZ2h0LnR5cGUgPT09ICdzdHJlYW0nKVxuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAnPCc6IGZ1bmN0aW9uIGx0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJlYW0nIHx8IHJpZ2h0LnR5cGUgPT09ICdzdHJlYW0nKVxuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9LFxuICAgICc8PSc6IGZ1bmN0aW9uIGx0ZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnc3RyZWFtJyB8fCByaWdodC50eXBlID09PSAnc3RyZWFtJylcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgIFwiaW5cIjogZnVuY3Rpb24gaW5vcChsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgcmlnaHRfMSwgcmlnaHRfMV8xO1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGIsIGVfMV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJpZ2h0LmRhdGEubWF0Y2hlcyhsZWZ0LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmlnaHQuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgNiwgNywgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0XzEgPSBfX2FzeW5jVmFsdWVzKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCByaWdodF8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJpZ2h0XzFfMSA9IF9iLnNlbnQoKSwgIXJpZ2h0XzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gcmlnaHRfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgVFJVRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbNywgLCAxMCwgMTFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJpZ2h0XzFfMSAmJiAhcmlnaHRfMV8xLmRvbmUgJiYgKF9hID0gcmlnaHRfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwocmlnaHRfMSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5zLCBwYXR0ZXJucywgZGlkU3VjY2VlZCwgbWF0Y2hlZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdhdGhlclRleHQobGVmdCwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdhdGhlclRleHQocmlnaHQsIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU3VjY2VlZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1hdGNoZWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgICcrJzogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnZGF0ZXRpbWUnICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdudW1iZXInICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEgKyByaWdodC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnc3RyaW5nJyAmJiByaWdodC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ29iamVjdCcgJiYgcmlnaHQudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSlMoX19hc3NpZ24oX19hc3NpZ24oe30sIGxlZnQuZGF0YSksIHJpZ2h0LmRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnYXJyYXknICYmIHJpZ2h0LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0XzEsIGxlZnRfMV8xLCB2YWwsIGVfMl8xLCByaWdodF8yLCByaWdodF8yXzEsIHZhbCwgZV8zXzE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlXzIsIF9hLCBlXzMsIF9iO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRfMSA9IF9fYXN5bmNWYWx1ZXMobGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQobGVmdF8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobGVmdF8xXzEgPSBfYy5zZW50KCksICFsZWZ0XzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGxlZnRfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShsZWZ0XzFfMSAmJiAhbGVmdF8xXzEuZG9uZSAmJiAoX2EgPSBsZWZ0XzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9hLmNhbGwobGVmdF8xKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEzLCAyMCwgMjEsIDI2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0XzIgPSBfX2FzeW5jVmFsdWVzKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHJpZ2h0XzIubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMl8xID0gX2Muc2VudCgpLCAhcmlnaHRfMl8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJpZ2h0XzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWwpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMjZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfM18xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzMgPSB7IGVycm9yOiBlXzNfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsyMSwgLCAyNCwgMjVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMl8xICYmICFyaWdodF8yXzEuZG9uZSAmJiAoX2IgPSByaWdodF8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDIzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYi5jYWxsKHJpZ2h0XzIpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfSxcbiAgICAnLSc6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdkYXRldGltZScgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdkYXRldGltZScgJiYgcmlnaHQudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdudW1iZXInICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEgLSByaWdodC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgICcqJzogbnVtZXJpY09wZXJhdG9yKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICogYjsgfSksXG4gICAgJy8nOiBudW1lcmljT3BlcmF0b3IoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLyBiOyB9KSxcbiAgICAnJSc6IG51bWVyaWNPcGVyYXRvcihmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAlIGI7IH0pLFxuICAgICcqKic6IG51bWVyaWNPcGVyYXRvcihmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5wb3coYSwgYik7IH0pXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdudW1iZXInICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9O1xufXZhciBTY29wZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIGZ1bmN0aW9uIFNjb3BlKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBTY29wZS5wcm90b3R5cGUuY3JlYXRlTmVzdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzKTtcbiAgICB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS5jcmVhdGVIaWRkZW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0LmlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTY29wZTtcbn0oKSk7ZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBpZiAoZXhlY3V0ZSA9PT0gdm9pZCAwKSB7IGV4ZWN1dGUgPSBldmFsdWF0ZTsgfVxuICAgIHZhciBmdW5jID0gRVhFQ1VUT1JTW25vZGUudHlwZV07XG4gICAgcmV0dXJuIGZ1bmMobm9kZSwgc2NvcGUsIGV4ZWN1dGUpO1xufVxuLyoqXG4gKiBBcHBsaWVzIHRoZSBmdW5jdGlvbiB0byBhIHZhbHVlLCBidXQgdHJpZXMgdG8gYXZvaWQgY3JlYXRpbmcgdW5uZWNlc3NhcnkgcHJvbWlzZXMuXG4gKi9cbmZ1bmN0aW9uIHByb21pc2VsZXNzQXBwbHkodmFsdWUsIGNiKSB7XG4gICAgaWYgKCd0aGVuJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudGhlbihjYik7XG4gICAgfVxuICAgIHJldHVybiBjYih2YWx1ZSk7XG59XG52YXIgRVhFQ1VUT1JTID0ge1xuICAgIFRoaXM6IGZ1bmN0aW9uIChfLCBzY29wZSkge1xuICAgICAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gICAgfSxcbiAgICBTZWxlY3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGVzZSBzaG91bGQgYmUgZXZhbHVhdGVkIHNlcGFyZWx5IHVzaW5nIGEgZGlmZmVyZW50IGV2YWx1YXRvci5cbiAgICAgICAgLy8gQXQgdGhlIG1vb21lbnQgd2UgaGF2ZW4ndCBpbXBsZW1lbnRlZCB0aGlzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbGVjdG9ycyBjYW4gbm90IGJlIGV2YWx1YXRlZCcpO1xuICAgIH0sXG4gICAgRXZlcnl0aGluZzogZnVuY3Rpb24gKF8sIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzY29wZS5zb3VyY2U7XG4gICAgfSxcbiAgICBQYXJhbWV0ZXI6IGZ1bmN0aW9uIChfYSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICByZXR1cm4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSk7XG4gICAgfSxcbiAgICBDb250ZXh0OiBmdW5jdGlvbiAoX2EsIHNjb3BlKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYS5rZXk7XG4gICAgICAgIGlmIChrZXkgPT09ICdiZWZvcmUnIHx8IGtleSA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGUuY29udGV4dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IE5VTExfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjb250ZXh0IGtleTogXCIuY29uY2F0KGtleSkpO1xuICAgIH0sXG4gICAgUGFyZW50OiBmdW5jdGlvbiAoX2EsIHNjb3BlKSB7XG4gICAgICAgIHZhciBuID0gX2EubjtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBzY29wZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICB9LFxuICAgIE9wQ2FsbDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3AgPSBfYS5vcCwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgIHZhciBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yOiBcIi5jb25jYXQob3ApKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgICAgIHZhciByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgICAgICAvLyBBdm9pZCB1bmVjY2VzYXJ5IHByb21pc2VzXG4gICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGNvbnN0YW50IGV2YWx1YXRpb24gdG8gd29yayBjb3JyZWN0bHkuXG4gICAgICAgIGlmICgndGhlbicgaW4gbGVmdFZhbHVlIHx8ICd0aGVuJyBpbiByaWdodFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgdmFyIF9hLCBfYjsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBmdW5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGVmdFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBbX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJpZ2h0VmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh2b2lkIDAsIF9iLmNvbmNhdChbX2Muc2VudCgpXSkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgfSk7IH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICB9LFxuICAgIFNlbGVjdDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmVzID0gX2EuYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayA9IF9hLmZhbGxiYWNrO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIGFsdGVybmF0aXZlc18xLCBhbHQsIGFsdENvbmQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIGFsdGVybmF0aXZlc18xID0gYWx0ZXJuYXRpdmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGFsdGVybmF0aXZlc18xLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ID0gYWx0ZXJuYXRpdmVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRDb25kID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsdENvbmQudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGFsdENvbmQuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleGVjdXRlKGFsdC52YWx1ZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXhlY3V0ZShmYWxsYmFjaywgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBJblJhbmdlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQsIGlzSW5jbHVzaXZlID0gX2EuaXNJbmNsdXNpdmU7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgbGVmdFZhbHVlLCByaWdodFZhbHVlLCBsZWZ0Q21wLCBfYiwgX2MsIHJpZ2h0Q21wLCBfZCwgX2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGxlZnQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRWYWx1ZSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUocmlnaHQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHBhcnRpYWxDb21wYXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IFtfZi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGVmdFZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdENtcCA9IF9iLmFwcGx5KHZvaWQgMCwgX2MuY29uY2F0KFtfZi5zZW50KCldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdENtcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gcGFydGlhbENvbXBhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gW19mLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByaWdodFZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRDbXAgPSBfZC5hcHBseSh2b2lkIDAsIF9lLmNvbmNhdChbX2Yuc2VudCgpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBGaWx0ZXI6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBleHByID0gX2EuZXhwcjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVZhbHVlXzEsIGJhc2VWYWx1ZV8xXzEsIGVsZW0sIG5ld1Njb3BlLCBleHByVmFsdWUsIGVfMV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzAsIDgsIDksIDE0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWVfMSA9IF9fYXN5bmNWYWx1ZXMoYmFzZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGJhc2VWYWx1ZV8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlVmFsdWVfMV8xID0gX2Iuc2VudCgpLCAhYmFzZVZhbHVlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gYmFzZVZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChleGVjdXRlKGV4cHIsIG5ld1Njb3BlKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShleHByVmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGV4cHJWYWx1ZS5kYXRhID09PSB0cnVlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGVsZW0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOSwgLCAxMiwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJhc2VWYWx1ZV8xXzEgJiYgIWJhc2VWYWx1ZV8xXzEuZG9uZSAmJiAoX2EgPSBiYXNlVmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9hLmNhbGwoYmFzZVZhbHVlXzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBQcm9qZWN0aW9uOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgZXhwciA9IF9hLmV4cHI7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlVmFsdWUsIG5ld1Njb3BlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBGdW5jQ2FsbDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IF9hLmZ1bmMsIGFyZ3MgPSBfYS5hcmdzO1xuICAgICAgICByZXR1cm4gZnVuYyhhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgfSxcbiAgICBQaXBlRnVuY0NhbGw6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBfYS5mdW5jLCBiYXNlID0gX2EuYmFzZSwgYXJncyA9IF9hLmFyZ3M7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZ1bmMoYmFzZVZhbHVlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEFjY2Vzc0F0dHJpYnV0ZTogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2UsIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNjb3BlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5kYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlModmFsdWUuZGF0YVtuYW1lXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBY2Nlc3NFbGVtZW50OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgaW5kZXggPSBfYS5pbmRleDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSwgZGF0YSwgZmluYWxJbmRleDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBiYXNlVmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFNsaWNlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQsIGlzSW5jbHVzaXZlID0gX2EuaXNJbmNsdXNpdmU7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlVmFsdWUsIGFycmF5LCBsZWZ0SWR4LCByaWdodElkeDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBiYXNlVmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheSA9IChfYi5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdElkeCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodElkeCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SWR4ID0gYXJyYXkubGVuZ3RoICsgbGVmdElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodElkeCA9IGFycmF5Lmxlbmd0aCArIHJpZ2h0SWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIGluY2x1c2l2ZSB0byBleGNsdXNpdmUgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodElkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBBdCB0aGlzIHBvaW50IHRoZSBpbmRpY2VzIG1pZ2h0IHBvaW50IG91dC1vZi1ib3VuZCwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc2xpY2UgaGFuZGxlcyB0aGlzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoYXJyYXkuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgRGVyZWY6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGVfMiwgX2I7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBpZCwgX2MsIF9kLCBkb2MsIGVfMl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5kYXRhLl9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2UudHJ5cy5wdXNoKFsyLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBfX2FzeW5jVmFsdWVzKHNjb3BlLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2MubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2QgPSBfZS5zZW50KCksICFfZC5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2MudHlwZSA9PT0gJ29iamVjdCcgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkb2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yXzEgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZCAmJiAhX2QuZG9uZSAmJiAoX2IgPSBfY1tcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5jYWxsKF9jKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBWYWx1ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgICB9LFxuICAgIEdyb3VwOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIH0sXG4gICAgT2JqZWN0OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gX2EuYXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2ksIGF0dHJpYnV0ZXNfMSwgYXR0ciwgYXR0clR5cGUsIF9iLCB2YWx1ZSwgX2MsIF9kLCBjb25kLCB2YWx1ZSwgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYXR0cmlidXRlc18xID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBhdHRyaWJ1dGVzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gYXR0ci50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ09iamVjdEF0dHJpYnV0ZVZhbHVlJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT2JqZWN0Q29uZGl0aW9uYWxTcGxhdCc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ09iamVjdFNwbGF0JzogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jW19kXSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gJ2Jvb2xlYW4nIHx8IGNvbmQuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIi5jb25jYXQoYXR0clR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBcnJheTogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBfYS5lbGVtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2ksIGVsZW1lbnRzXzEsIGVsZW1lbnQsIHZhbHVlLCB2YWx1ZV8xLCB2YWx1ZV8xXzEsIHYsIGVfM18xO1xuICAgICAgICAgICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgZWxlbWVudHNfMSA9IGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGVsZW1lbnRzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZWxlbWVudC52YWx1ZSwgc2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmlzU3BsYXQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzMsIDEwLCAxMSwgMTZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV8xID0gKGVfMyA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWx1ZV8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSA9IF9iLnNlbnQoKSwgIXZhbHVlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHYpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzNfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzMgPSB7IGVycm9yOiBlXzNfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxMSwgLCAxNCwgMTVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8xXzEgJiYgIXZhbHVlXzFfMS5kb25lICYmIChfYSA9IHZhbHVlXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWx1ZV8xKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMjBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxODogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFR1cGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkJyk7XG4gICAgfSxcbiAgICBPcjogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobGVmdCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShyaWdodCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09ICdib29sZWFuJyB8fCByaWdodFZhbHVlLnR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgQW5kOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShsZWZ0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKHJpZ2h0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodFZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09ICdib29sZWFuJyB8fCByaWdodFZhbHVlLnR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBOb3Q6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIE5lZzogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2U7XG4gICAgICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFBvczogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2U7XG4gICAgICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgQXNjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgRGVzYzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgIEFycmF5Q29lcmNlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgTWFwOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgZXhwciA9IF9hLmV4cHI7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzIsIHZhbHVlXzJfMSwgZWxlbSwgbmV3U2NvcGUsIGVfNF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzAsIDgsIDksIDE0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV8yID0gX19hc3luY1ZhbHVlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWx1ZV8yLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8yXzEgPSBfYi5zZW50KCksICF2YWx1ZV8yXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHZhbHVlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChleGVjdXRlKGV4cHIsIG5ld1Njb3BlKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNF8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV80ID0geyBlcnJvcjogZV80XzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs5LCAsIDEyLCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMl8xICYmICF2YWx1ZV8yXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWx1ZV8yKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgRmxhdE1hcDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2UsIGV4cHIgPSBfYS5leHByO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgU3RyZWFtVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8zLCB2YWx1ZV8zXzEsIGVsZW0sIG5ld1Njb3BlLCBpbm5lclZhbHVlLCBpbm5lclZhbHVlXzEsIGlubmVyVmFsdWVfMV8xLCBpbm5lciwgZV81XzEsIGVfNl8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfNiwgX2EsIGVfNSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDIzLCAyNCwgMjldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXzMgPSBfX2FzeW5jVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlXzMubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzNfMSA9IF9jLnNlbnQoKSwgIXZhbHVlXzNfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHZhbHVlXzNfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChleGVjdXRlKGV4cHIsIG5ld1Njb3BlKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclZhbHVlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbm5lclZhbHVlLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzQsIDExLCAxMiwgMTddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsdWVfMSA9IChlXzUgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMoaW5uZXJWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoaW5uZXJWYWx1ZV8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lclZhbHVlXzFfMSA9IF9jLnNlbnQoKSwgIWlubmVyVmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lciA9IGlubmVyVmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChpbm5lcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV81XzEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzUgPSB7IGVycm9yOiBlXzVfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxMiwgLCAxNSwgMTZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyVmFsdWVfMV8xICYmICFpbm5lclZhbHVlXzFfMS5kb25lICYmIChfYiA9IGlubmVyVmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9iLmNhbGwoaW5uZXJWYWx1ZV8xKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGlubmVyVmFsdWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOiByZXR1cm4gWzMgLypicmVhayovLCAyOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzZfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNiA9IHsgZXJyb3I6IGVfNl8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzI0LCAsIDI3LCAyOF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfM18xICYmICF2YWx1ZV8zXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8zW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDI2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWx1ZV8zKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMjhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyODogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIEV2YWx1YXRlcyBhIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHRyZWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByb290ID0gZnJvbUpTKG9wdGlvbnMucm9vdCk7XG4gICAgdmFyIGRhdGFzZXQgPSBmcm9tSlMob3B0aW9ucy5kYXRhc2V0KTtcbiAgICB2YXIgcGFyYW1zID0gX19hc3NpZ24oe30sIG9wdGlvbnMucGFyYW1zKTtcbiAgICB2YXIgc2NvcGUgPSBuZXcgU2NvcGUocGFyYW1zLCBkYXRhc2V0LCByb290LCB7XG4gICAgICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAgfHwgbmV3IERhdGUoKSxcbiAgICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHVuZGVmaW5lZCA/ICdtZScgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgICBhZnRlcjogb3B0aW9ucy5hZnRlciA/IGZyb21KUyhvcHRpb25zLmFmdGVyKSA6IG51bGwsXG4gICAgICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbFxuICAgIH0sIG51bGwpO1xuICAgIHJldHVybiBldmFsdWF0ZSh0cmVlLCBzY29wZSk7XG59ZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnR3JvdXAnOlxuICAgICAgICBjYXNlICdWYWx1ZSc6XG4gICAgICAgIGNhc2UgJ1BhcmFtZXRlcic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnUG9zJzpcbiAgICAgICAgY2FzZSAnTmVnJzpcbiAgICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgICAgIGNhc2UgJ09wQ2FsbCc6XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBjYXNlICcqKic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlKHt9LCBOVUxMX1ZBTFVFLCBOVUxMX1ZBTFVFLCB7IHRpbWVzdGFtcDogbmV3IERhdGUoMCksIGlkZW50aXR5OiAnbWUnLCBiZWZvcmU6IG51bGwsIGFmdGVyOiBudWxsIH0sIG51bGwpO1xuZnVuY3Rpb24gdHJ5Q29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gICAgaWYgKCFjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RhbnRFdmFsdWF0ZShub2RlKTtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IGV2YWx1YXRlKG5vZGUsIERVTU1ZX1NDT1BFLCBjb25zdGFudEV2YWx1YXRlKTtcbiAgICBpZiAoJ3RoZW4nIGluIHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59dmFyIEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1wiJzogJ1wiJyxcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAnLyc6ICcvJyxcbiAgICBiOiAnXFxiJyxcbiAgICBmOiAnXFxmJyxcbiAgICBuOiAnXFxuJyxcbiAgICByOiAnXFxyJyxcbiAgICB0OiAnXFx0J1xufTtcbmZ1bmN0aW9uIGV4cGFuZEhleChzdHIpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG52YXIgR3JvcVF1ZXJ5RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3FRdWVyeUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3FRdWVyeUVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdHcm9xUXVlcnlFcnJvcic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdyb3FRdWVyeUVycm9yO1xufShFcnJvcikpO1xudmFyIEVYUFJfQlVJTERFUiA9IHtcbiAgICBncm91cDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGlubmVyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnR3JvdXAnLFxuICAgICAgICAgICAgYmFzZTogaW5uZXJcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGV2ZXJ5dGhpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0V2ZXJ5dGhpbmcnIH07XG4gICAgfSxcbiAgICBcInRoaXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnVGhpcycgfTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BhcmVudCcsXG4gICAgICAgICAgICBuOiAxXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkYmxwYXJlbnQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGFyZW50JyxcbiAgICAgICAgICAgIG46IG5leHQubiArIDFcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ3RyYXZlcnNhbF9lbmQnKSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHZhciB0cmF2ZXJzYWwgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlLnR5cGUgPT09ICdFdmVyeXRoaW5nJyB8fCBiYXNlLnR5cGUgPT09ICdBcnJheScgfHwgYmFzZS50eXBlID09PSAnUGlwZUZ1bmNDYWxsJykge1xuICAgICAgICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWw7IH0sIHRyYXZlcnNhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYXZlcnNhbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbCcpO1xuICAgICAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICAgIH0sXG4gICAgdGhpc19hdHRyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnVmFsdWUnLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG5lZzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdOZWcnLFxuICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcG9zOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BvcycsXG4gICAgICAgICAgICBiYXNlOiBiYXNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJysnLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3ViOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICctJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG11bDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnKicsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkaXY6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJy8nLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbW9kOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICclJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBvdzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnKionLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIG9wID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogb3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpbl9yYW5nZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gJ2luY19yYW5nZSc7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnSW5SYW5nZScsXG4gICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgIGlzSW5jbHVzaXZlOiBpc0luY2x1c2l2ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3RyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICBsb29wOiB3aGlsZSAocC5oYXNNYXJrKCkpIHtcbiAgICAgICAgICAgIHZhciBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cl9lbmQnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cl9wYXVzZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJfc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZV9lc2NhcGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gcC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd1bmljb2RlX2hleCc6XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBtYXJrOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IHZhbHVlIH07XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdWYWx1ZScsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZmxvYXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzY2k6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAnb2JqZWN0X2VuZCcpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0JyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFycmF5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICdhcnJheV9lbmQnKSB7XG4gICAgICAgICAgICB2YXIgaXNTcGxhdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdhcnJheV9zcGxhdCcpIHtcbiAgICAgICAgICAgICAgICBpc1NwbGF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBcnJheUVsZW1lbnQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpc1NwbGF0OiBpc1NwbGF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnQXJyYXknLFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0dXBsZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG1lbWJlcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICd0dXBsZV9lbmQnKSB7XG4gICAgICAgICAgICBtZW1iZXJzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdUdXBsZScsXG4gICAgICAgICAgICBtZW1iZXJzOiBtZW1iZXJzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBmdW5jX2NhbGw6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSAnZ2xvYmFsJztcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICduYW1lc3BhY2UnKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICBpZiAobmFtZXNwYWNlID09PSAnZ2xvYmFsJyAmJiBuYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU2VsZWN0JyxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICdmdW5jX2FyZ3NfZW5kJykge1xuICAgICAgICAgICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSAncGFpcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsdGVybmF0aXZlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTZWxlY3RBbHRlcm5hdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ2Z1bmNfYXJnc19lbmQnKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgbmFtZSwgYXJncy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIGRpZmYvZGVsdGEgZnVuY3Rpb25zIGFyZW4ndCB2YWxpZGF0ZWQgeWV0IHdlIG9ubHkgd2FudCB0byB2YWxpZGF0ZSB0aGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAvLyBiZWluZyB1c2VkLiBXZSBleHBlY3QgdGhlIG51bGwgdmFsdWVkIGFyZyB0byB0aHJvdyBhbiBlcnJvciBhdCBldmFsdWF0aW9uIHRpbWUuXG4gICAgICAgICAgICAgICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6ICdTZWxlY3RvcicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gJ2dsb2JhbCcgJiYgKG5hbWUgPT09ICdiZWZvcmUnIHx8IG5hbWUgPT09ICdhZnRlcicpKSB7XG4gICAgICAgICAgICBpZiAocC5wYXJzZU9wdGlvbnMubW9kZSA9PT0gJ2RlbHRhJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDb250ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuYW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlID09PSAnZ2xvYmFsJyAmJiBuYW1lID09PSAnYm9vc3QnICYmICFwLmFsbG93Qm9vc3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3VuZXhwZWN0ZWQgYm9vc3QnKTtcbiAgICAgICAgdmFyIGZ1bmNzID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VdO1xuICAgICAgICBpZiAoIWZ1bmNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgbmFtZXNwYWNlOiBcIi5jb25jYXQobmFtZXNwYWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMuYXJpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMubW9kZSAhPT0gdW5kZWZpbmVkICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnRnVuY0NhbGwnLFxuICAgICAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwaXBlY2FsbDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcC5zaGlmdCgpOyAvLyBSZW1vdmUgdGhlIGZ1bmNfY2FsbFxuICAgICAgICB2YXIgbmFtZXNwYWNlID0gJ2dsb2JhbCc7XG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSAnbmFtZXNwYWNlJykge1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBuYW1lc3BhY2U6IFwiLmNvbmNhdChuYW1lc3BhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB2YXIgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzY29yZScpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWxsb3cgYm9vc3QgaW5zaWRlIGEgc2NvcmUgZXhwcmVzc2lvblxuICAgICAgICAgICAgcC5hbGxvd0Jvb3N0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB2YXIgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1hcmtOYW1lID09PSAnZnVuY19hcmdzX2VuZCcpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb3JkZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtOYW1lID09PSAnYXNjJykge1xuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6ICdBc2MnLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcmtOYW1lID09PSAnZGVzYycpIHtcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiAnRGVzYycsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcbiAgICAgICAgdmFyIGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBwaXBlIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jLmFyaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BpcGVGdW5jQ2FsbCcsXG4gICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYWlyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICAgIH0sXG4gICAgYW5kOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBbmQnLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb3I6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09yJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdOb3QnLFxuICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3VuZXhwZWN0ZWQgYXNjJyk7XG4gICAgfSxcbiAgICBkZXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3VuZXhwZWN0ZWQgZGVzYycpO1xuICAgIH0sXG4gICAgcGFyYW06IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdWYWx1ZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BhcmFtZXRlcicsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgfVxufTtcbnZhciBPQkpFQ1RfQlVJTERFUiA9IHtcbiAgICBvYmplY3RfZXhwcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdwYWlyJykge1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdENvbmRpdGlvbmFsU3BsYXQnLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZV8xXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdEF0dHJpYnV0ZVZhbHVlJyxcbiAgICAgICAgICAgIG5hbWU6IGV4dHJhY3RQcm9wZXJ0eUtleSh2YWx1ZSksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9wYWlyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICBpZiAobmFtZS50eXBlICE9PSAnVmFsdWUnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdEF0dHJpYnV0ZVZhbHVlJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9zcGxhdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0U3BsYXQnLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvYmplY3Rfc3BsYXRfdGhpczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdFNwbGF0JyxcbiAgICAgICAgICAgIHZhbHVlOiB7IHR5cGU6ICdUaGlzJyB9XG4gICAgICAgIH07XG4gICAgfVxufTtcbnZhciBUUkFWRVJTRV9CVUlMREVSID0ge1xuICAgIHNxdWFyZV9icmFja2V0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VFbGVtZW50KGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnQWNjZXNzRWxlbWVudCcsIGJhc2U6IGJhc2UsIGluZGV4OiB2YWx1ZS5kYXRhIH0pOyB9LCByaWdodCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZVBsYWluKGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJywgYmFzZTogYmFzZSwgbmFtZTogdmFsdWUuZGF0YSB9KTsgfSwgcmlnaHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRmlsdGVyJyxcbiAgICAgICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgICAgIGV4cHI6IGV4cHJcbiAgICAgICAgICAgIH0pOyB9LCByaWdodCk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzbGljZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gJ2luY19yYW5nZSc7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpO1xuICAgICAgICB2YXIgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgICAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gJ251bWJlcicgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKCdzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlQXJyYXkoZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NsaWNlJyxcbiAgICAgICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnRWYWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgaXNJbmNsdXNpdmU6IGlzSW5jbHVzaXZlXG4gICAgICAgICAgICB9KTsgfSwgcmhzKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlUHJvamVjdGlvbihmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHsgdHlwZTogJ1Byb2plY3Rpb24nLCBiYXNlOiBiYXNlLCBleHByOiBvYmogfSk7IH0sIHJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGF0dHJfYWNjZXNzOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7IHJldHVybiB0cmF2ZXJzZVBsYWluKGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJywgYmFzZTogYmFzZSwgbmFtZTogbmFtZSB9KTsgfSwgcmlnaHQpOyB9O1xuICAgIH0sXG4gICAgZGVyZWY6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBhdHRyID0gbnVsbDtcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdkZXJlZl9hdHRyJykge1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgYXR0ciA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyID8geyB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJywgYmFzZTogYmFzZSwgbmFtZTogYXR0ciB9IDogYmFzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlUGxhaW4oZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdEZXJlZicsXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IGJhc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFycmF5X3Bvc3RmaXg6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHsgcmV0dXJuIHRyYXZlcnNlQXJyYXkoZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBcnJheUNvZXJjZScsIGJhc2U6IGJhc2UgfSk7IH0sIHJpZ2h0KTsgfTtcbiAgICB9XG59O1xudmFyIFNFTEVDVE9SX0JVSUxERVIgPSB7XG4gICAgZ3JvdXA6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBldmVyeXRoaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIFwidGhpc1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBkYmxwYXJlbnQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAndHJhdmVyc2FsX2VuZCcpIHtcbiAgICAgICAgICAgIHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgdGhpc19hdHRyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBuZWc6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBvczogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBzdWI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIG11bDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgZGl2OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBtb2Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBvdzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgY29tcDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgaW5fcmFuZ2U6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHN0cjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgZmxvYXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHNjaTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgb2JqZWN0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBhcnJheTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgdHVwbGU6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgdGhyb3cgYW4gZXJyb3IgdW50aWwgd2UgYWRkIHN1cHBvcnQgZm9yIHR1cGxlcyBpbiBzZWxlY3RvcnMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGZ1bmNfY2FsbDogZnVuY3Rpb24gKHAsIG1hcmspIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgICAgICBpZiAoZnVuYy5uYW1lID09PSAnYW55d2hlcmUnICYmIGZ1bmMuYXJncy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcGlwZWNhbGw6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBhaXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGFuZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgb3I6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgYXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBkZXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBwYXJhbTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdBY2Nlc3NBdHRyaWJ1dGUnICYmICFub2RlLmJhc2UpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0RlcmVmJyB8fFxuICAgICAgICBub2RlLnR5cGUgPT09ICdNYXAnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ1Byb2plY3Rpb24nIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ1NsaWNlJyB8fFxuICAgICAgICBub2RlLnR5cGUgPT09ICdGaWx0ZXInIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ0FjY2Vzc0VsZW1lbnQnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ0FycmF5Q29lcmNlJykge1xuICAgICAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkNhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkga2V5IGZvciB0eXBlOiBcIi5jb25jYXQobm9kZS50eXBlKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGFyaXR5LCBjb3VudCkge1xuICAgIGlmICh0eXBlb2YgYXJpdHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChjb3VudCAhPT0gYXJpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLiBFeHBlY3RlZCBcIikuY29uY2F0KGFyaXR5LCBcIiwgZ290IFwiKS5jb25jYXQoY291bnQsIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXJpdHkpIHtcbiAgICAgICAgaWYgKCFhcml0eShjb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gICAgdmFyIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFsnY2hhbmdlZEFueScsICdjaGFuZ2VkT25seSddO1xuICAgIHJldHVybiBuYW1lc3BhY2UgPT0gJ2RpZmYnICYmIGFyZ0NvdW50ID09IDIgJiYgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzLmluY2x1ZGVzKGZ1bmN0aW9uTmFtZSk7XG59XG52YXIgR3JvcVN5bnRheEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm9xU3ludGF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvcVN5bnRheEVycm9yKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gXCIuY29uY2F0KHBvc2l0aW9uKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdHcm9xU3ludGF4RXJyb3InO1xuICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHcm9xU3ludGF4RXJyb3I7XG59KEVycm9yKSk7XG4vKipcbiAqIFBhcnNlcyBhIEdST1EgcXVlcnkgYW5kIHJldHVybnMgYSB0cmVlIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcbiAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24pO1xuICAgIH1cbiAgICB2YXIgcHJvY2Vzc29yID0gbmV3IE1hcmtQcm9jZXNzb3IoaW5wdXQsIHJlc3VsdC5tYXJrcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHByb2Nlc3Nvci5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59ZXhwb3J0e2V2YWx1YXRlUXVlcnkgYXMgZXZhbHVhdGUscGFyc2V9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/groq-js/dist/1.esm.mjs\n"));

/***/ }),

/***/ "./node_modules/throttle-debounce/esm/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/throttle-debounce/esm/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debounce\": function() { return /* binding */ debounce; },\n/* harmony export */   \"throttle\": function() { return /* binding */ throttle; }\n/* harmony export */ });\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nfunction throttle (delay, callback, options) {\n  var _ref = options || {},\n      _ref$noTrailing = _ref.noTrailing,\n      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,\n      _ref$noLeading = _ref.noLeading,\n      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,\n      _ref$debounceMode = _ref.debounceMode,\n      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n\n\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel(options) {\n    var _ref2 = options || {},\n        _ref2$upcomingOnly = _ref2.upcomingOnly,\n        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\n\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (!noLeading && debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`\n       * and noLeading != true.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      if (noLeading) {\n        /*\n         * In throttle mode with noLeading, if `delay` time has\n         * been exceeded, update `lastExec` and schedule `callback`\n         * to execute after `delay` ms.\n         */\n        lastExec = Date.now();\n\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        /*\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n         * `callback`.\n         */\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, callback, options) {\n  var _ref = options || {},\n      _ref$atBegin = _ref.atBegin,\n      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\n\n  return throttle(delay, callback, {\n    debounceMode: atBegin !== false\n  });\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHlCQUF5Qjs7QUFFekIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw4RUFBOEUsYUFBYTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvZXNtL2luZGV4LmpzPzkzNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xuXG4vKipcbiAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xuICogZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtICAgICAgICAgICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBtb3N0IHVzZWZ1bC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gICAgICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcy1pcywgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gICAgICAgICAgICAgIEFuIG9iamVjdCB0byBjb25maWd1cmUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9UcmFpbGluZ10gLSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGZpbmFsIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9MZWFkaW5nXSAtICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub0xlYWRpbmcgaXMgZmFsc2UsIHRoZSBmaXJzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbCB3aWxsIGV4ZWN1dGUgY2FsbGJhY2tcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseS4gSWYgbm9MZWFkaW5nIGlzIHRydWUsIHRoZSBmaXJzdCB0aGUgY2FsbGJhY2sgZXhlY3V0aW9uIHdpbGwgYmUgc2tpcHBlZC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayB3aWxsIG5ldmVyIGV4ZWN1dGVkIGlmIGJvdGggbm9MZWFkaW5nID0gdHJ1ZSBhbmQgbm9UcmFpbGluZyA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlYm91bmNlTW9kZV0gLSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0aHJvdHRsZSAoZGVsYXksIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgIF9yZWYkbm9UcmFpbGluZyA9IF9yZWYubm9UcmFpbGluZyxcbiAgICAgIG5vVHJhaWxpbmcgPSBfcmVmJG5vVHJhaWxpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRub1RyYWlsaW5nLFxuICAgICAgX3JlZiRub0xlYWRpbmcgPSBfcmVmLm5vTGVhZGluZyxcbiAgICAgIG5vTGVhZGluZyA9IF9yZWYkbm9MZWFkaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbm9MZWFkaW5nLFxuICAgICAgX3JlZiRkZWJvdW5jZU1vZGUgPSBfcmVmLmRlYm91bmNlTW9kZSxcbiAgICAgIGRlYm91bmNlTW9kZSA9IF9yZWYkZGVib3VuY2VNb2RlID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmJGRlYm91bmNlTW9kZTtcbiAgLypcbiAgICogQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcbiAgICogYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXG4gICAqIGRlYm91bmNlIG1vZGVzLlxuICAgKi9cblxuXG4gIHZhciB0aW1lb3V0SUQ7XG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxuXG4gIHZhciBsYXN0RXhlYyA9IDA7IC8vIEZ1bmN0aW9uIHRvIGNsZWFyIGV4aXN0aW5nIHRpbWVvdXRcblxuICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcbiAgICBpZiAodGltZW91dElEKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICB9XG4gIH0gLy8gRnVuY3Rpb24gdG8gY2FuY2VsIG5leHQgZXhlY1xuXG5cbiAgZnVuY3Rpb24gY2FuY2VsKG9wdGlvbnMpIHtcbiAgICB2YXIgX3JlZjIgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBfcmVmMiR1cGNvbWluZ09ubHkgPSBfcmVmMi51cGNvbWluZ09ubHksXG4gICAgICAgIHVwY29taW5nT25seSA9IF9yZWYyJHVwY29taW5nT25seSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiR1cGNvbWluZ09ubHk7XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuICAgIGNhbmNlbGxlZCA9ICF1cGNvbWluZ09ubHk7XG4gIH1cbiAgLypcbiAgICogVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xuICAgKiBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxuICAgKiBpcyBleGVjdXRlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNfID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJndW1lbnRzX1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RFeGVjYCB0aW1lc3RhbXAuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XG4gICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHNfKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFub0xlYWRpbmcgJiYgZGVib3VuY2VNb2RlICYmICF0aW1lb3V0SUQpIHtcbiAgICAgIC8qXG4gICAgICAgKiBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcbiAgICAgICAqIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgZXhlY3V0ZSBgY2FsbGJhY2tgXG4gICAgICAgKiBhbmQgbm9MZWFkaW5nICE9IHRydWUuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoKTtcbiAgICB9XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXG4gICAgaWYgKGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xuICAgICAgaWYgKG5vTGVhZGluZykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlIHdpdGggbm9MZWFkaW5nLCBpZiBgZGVsYXlgIHRpbWUgaGFzXG4gICAgICAgICAqIGJlZW4gZXhjZWVkZWQsIHVwZGF0ZSBgbGFzdEV4ZWNgIGFuZCBzY2hlZHVsZSBgY2FsbGJhY2tgXG4gICAgICAgICAqIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAgICovXG4gICAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAoIW5vVHJhaWxpbmcpIHtcbiAgICAgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlIHdpdGhvdXQgbm9MZWFkaW5nLCBpZiBgZGVsYXlgIHRpbWUgaGFzIGJlZW4gZXhjZWVkZWQsIGV4ZWN1dGVcbiAgICAgICAgICogYGNhbGxiYWNrYC5cbiAgICAgICAgICovXG4gICAgICAgIGV4ZWMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vVHJhaWxpbmcgIT09IHRydWUpIHtcbiAgICAgIC8qXG4gICAgICAgKiBJbiB0cmFpbGluZyB0aHJvdHRsZSBtb2RlLCBzaW5jZSBgZGVsYXlgIHRpbWUgaGFzIG5vdCBiZWVuXG4gICAgICAgKiBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuICAgICAgICogcmVjZW50IGV4ZWN1dGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxuICAgICAgICogYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuICAgICAgICogZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICovXG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgPyBkZWxheSAtIGVsYXBzZWQgOiBkZWxheSk7XG4gICAgfVxuICB9XG5cbiAgd3JhcHBlci5jYW5jZWwgPSBjYW5jZWw7IC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cblxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG4vKipcbiAqIERlYm91bmNlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBEZWJvdW5jaW5nLCB1bmxpa2UgdGhyb3R0bGluZyxcbiAqIGd1YXJhbnRlZXMgdGhhdCBhIGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgYSBzaW5nbGUgdGltZSwgZWl0aGVyIGF0IHRoZVxuICogdmVyeSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgY2FsbHMsIG9yIGF0IHRoZSB2ZXJ5IGVuZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSAgICAgICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIGRlYm91bmNlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSAgICAgICAgICAgQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdEJlZ2luXSAtICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIGF0QmVnaW4gaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuIElmIGF0QmVnaW4gaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmx5IGF0IHRoZSBmaXJzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLCB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldCkuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlYm91bmNlIChkZWxheSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgX3JlZiRhdEJlZ2luID0gX3JlZi5hdEJlZ2luLFxuICAgICAgYXRCZWdpbiA9IF9yZWYkYXRCZWdpbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGF0QmVnaW47XG5cbiAgcmV0dXJuIHRocm90dGxlKGRlbGF5LCBjYWxsYmFjaywge1xuICAgIGRlYm91bmNlTW9kZTogYXRCZWdpbiAhPT0gZmFsc2VcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGRlYm91bmNlLCB0aHJvdHRsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/throttle-debounce/esm/index.js\n"));

/***/ })

}]);