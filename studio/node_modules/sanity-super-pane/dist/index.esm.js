import React, { createContext, useContext, useMemo, useState, useCallback, useEffect, useRef } from 'react';
import S from '@sanity/desk-tool/structure-builder';
import { get } from 'lodash';
import classNames from 'classnames';
import schema from 'part:@sanity/base/schema';
import SanityPreview from 'part:@sanity/base/preview';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { nanoid } from 'nanoid';
import { useToast, MenuButton, Button, Menu, MenuItem, MenuDivider, Dialog, Checkbox, Text, Box, Card, TextInput, Select, Flex, Label, Badge } from '@sanity/ui';
import { ResetIcon, UnpublishIcon, PublishIcon, TrashIcon, ChevronDownIcon, ChevronUpIcon, SortIcon, SyncIcon, SearchIcon, ControlsIcon, SpinnerIcon, EllipsisVerticalIcon, ArrowRightIcon, ChevronLeftIcon, ChevronRightIcon } from '@sanity/icons';
import _client from 'part:@sanity/base/client';
import { ErrorBoundary } from 'react-error-boundary';
import { tap, debounceTime } from 'rxjs/operators';

const RouterContext = /*#__PURE__*/createContext(null); // https://github.com/sanity-io/demo-custom-workflow/blob/d00b0f73fbf8543724772802749bd846078075d6/app/lib/router/internalRouterContextTypeCheck.js#L1

function internalRouterContextTypeCheck(context, propName, componentName) {
  if (!context.__internalRouter) {
    throw new Error('The router is accessed outside the context of a <RouterProvider>.' + ' No router state will be accessible and links will not go anywhere. To fix this,' + " make sure ".concat(componentName, " is rendered in the context of a <RouterProvider /> element"));
  }
} // https://github.com/sanity-io/demo-custom-workflow/blob/d00b0f73fbf8543724772802749bd846078075d6/app/lib/router/provider.js


class RouterProvider extends React.Component {
  render() {
    const router = this.context.__internalRouter;
    return /*#__PURE__*/React.createElement(RouterContext.Provider, {
      value: router
    }, this.props.children);
  }

}

_defineProperty(RouterProvider, "contextTypes", {
  __internalRouter: internalRouterContextTypeCheck
});

function useRouter() {
  return useContext(RouterContext);
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$4 = ".styles-module_content__PE-Ax {\n  padding: 0 1rem;\n}\n\n.styles-module_footer__zlbtL {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  justify-content: flex-end;\n  padding: 0.5rem;\n}\n";
var styles$4 = {"content":"styles-module_content__PE-Ax","footer":"styles-module_footer__zlbtL"};
styleInject(css_248z$4);

const client$2 = _client;

const ErroredDocuments = ({
  e,
  schemaType
}) => {
  const idsWithErrors = 'details' in e ? e.details.items.map(item => item.error.id) : [];

  if (!idsWithErrors.length) {
    return null;
  }

  const plural = idsWithErrors.length !== 1;
  return /*#__PURE__*/React.createElement(ErrorBoundary, {
    fallback: null
  }, /*#__PURE__*/React.createElement("p", null, "Please unselect ", plural ? 'these' : 'this', " document", plural ? 's' : '', ' ', "and try again:"), /*#__PURE__*/React.createElement("p", null, idsWithErrors.map(id => /*#__PURE__*/React.createElement(SanityPreview, {
    type: schemaType,
    key: id,
    value: {
      _id: id,
      _type: 'movie'
    }
  }))));
};

const removeDraftPrefix$1 = s => s.startsWith('drafts.') ? s.substring('drafts.'.length) : s;

function BulkActionsMenu({
  disabled,
  className,
  selectedIds,
  typeName,
  onDelete
}) {
  const buttonId = useMemo(nanoid, []);
  const schemaType = useMemo(() => schema.get(typeName), [typeName]);
  const toast = useToast();
  const dialogId = useMemo(nanoid, []);
  const [dialogMode, setDialogMode] = useState(null);
  const [loading, setLoading] = useState(false);

  const handleDiscardChanges = async () => {
    setLoading(true);

    try {
      const ids = await client$2.fetch('*[_id in $ids]._id', {
        ids: Array.from(selectedIds).map(id => [id, "drafts.".concat(id)]).flat()
      });
      const idSet = ids.reduce((set, id) => {
        set.add(id);
        return set;
      }, new Set());
      const draftIdsThatAlsoHavePublishedIds = ids.filter(id => id.startsWith('drafts.') && idSet.has(id.substring('drafts.'.length)));
      const t = client$2.transaction();

      for (const id of draftIdsThatAlsoHavePublishedIds) {
        t.delete(id);
      }

      await t.commit();
      setDialogMode(null);
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Discarding Changes',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk discard changes failed."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setLoading(false);
    }
  };

  const handleUnpublish = async () => {
    setLoading(true);

    try {
      const publishedDocuments = await client$2.fetch('*[_id in $ids]', {
        ids: Array.from(selectedIds)
      });
      const t = client$2.transaction();

      for (const publishedDocument of publishedDocuments) {
        t.createIfNotExists(Object.assign({}, publishedDocument, {
          _id: "drafts.".concat(publishedDocument._id),
          _updatedAt: new Date().toISOString()
        }));
        t.delete(publishedDocument._id);
      }

      await t.commit();
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Unpublishing',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk unpublished failed. This usually occurs because there are other documents referencing the documents you\u2019re trying to unpublish."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setDialogMode(null);
      setLoading(false);
    }
  };

  const handlePublish = async () => {
    setLoading(true);

    try {
      const draftDocuments = await client$2.fetch('*[_id in $ids]', {
        ids: Array.from(selectedIds).map(id => "drafts.".concat(id))
      });
      const t = client$2.transaction();

      for (const draftDocument of draftDocuments) {
        t.createOrReplace(Object.assign({}, draftDocument, {
          _id: removeDraftPrefix$1(draftDocument._id),
          _updatedAt: new Date().toISOString()
        }));
        t.delete(draftDocument._id);
      }

      await t.commit();
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Publishing',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk publish failed."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setDialogMode(null);
      setLoading(false);
    }
  };

  const handleDelete = async () => {
    setLoading(true);

    try {
      const idsToDelete = await client$2.fetch('*[_id in $ids]._id', {
        ids: Array.from(selectedIds).map(id => [id, "drafts.".concat(id)]).flat()
      });
      const t = client$2.transaction();

      for (const id of idsToDelete) {
        t.delete(id);
      }

      await t.commit();
      onDelete();
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Deleting',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk delete failed. This usually occurs because there are other documents referencing the documents you\u2019re trying to delete."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setDialogMode(null);
      setLoading(false);
    }
  };

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MenuButton, {
    button: disabled ? /*#__PURE__*/React.createElement(Button, {
      fontSize: 1,
      paddingY: 1,
      paddingX: 2,
      disabled: true
    }, "Bulk Actions") : /*#__PURE__*/React.createElement(Button, {
      fontSize: 1,
      paddingY: 1,
      paddingX: 2
    }, "Bulk Actions"),
    portal: true,
    id: buttonId,
    menu: /*#__PURE__*/React.createElement(Menu, {
      style: {
        textAlign: 'left'
      }
    }, /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      text: "Discard changes",
      icon: ResetIcon,
      onClick: () => setDialogMode('discard_changes')
    }), /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      text: "Unpublish",
      icon: UnpublishIcon,
      onClick: () => setDialogMode('unpublish')
    }), /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      text: "Publish",
      icon: PublishIcon,
      onClick: () => setDialogMode('publish')
    }), /*#__PURE__*/React.createElement(MenuDivider, null), /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      tone: "critical",
      icon: TrashIcon,
      text: "Delete",
      onClick: () => setDialogMode('delete')
    })),
    placement: "bottom"
  }), dialogMode === 'discard_changes' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Discard Changes"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$4.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Discard Changes",
      tone: "critical",
      mode: "ghost",
      disabled: loading,
      onClick: handleDiscardChanges
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$4.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to discard changes to", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "Discarding changes reverts changes made to any drafts of the selected documents and restores the currently published versions."), /*#__PURE__*/React.createElement("p", null, "You can use the", ' ', /*#__PURE__*/React.createElement("a", {
    href: "https://www.sanity.io/docs/history-experience",
    target: "_blank",
    rel: "noreferrer noopener"
  }, "document history"), ' ', "of each individual document to track these changes."))), dialogMode === 'unpublish' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Unpublish Documents"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$4.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Unpublish Documents",
      tone: "critical",
      mode: "ghost",
      disabled: loading,
      onClick: handleUnpublish
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$4.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to unpublish", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "If you unpublish a document, it will no longer be available to the public. Its contents will be moved into a draft if a draft does not already exist. From there you can continue to author the document and re-publish it later."), /*#__PURE__*/React.createElement("p", null, "You can use the", ' ', /*#__PURE__*/React.createElement("a", {
    href: "https://www.sanity.io/docs/history-experience",
    target: "_blank",
    rel: "noreferrer noopener"
  }, "document history"), ' ', "of each individual document to track these changes."))), dialogMode === 'publish' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Publish Documents"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$4.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Publish Documents",
      tone: "positive",
      disabled: loading,
      onClick: handlePublish
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$4.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to publish", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "Publishing a document makes the current contents of each document publicly available."), /*#__PURE__*/React.createElement("p", null, "You can use the", ' ', /*#__PURE__*/React.createElement("a", {
    href: "https://www.sanity.io/docs/history-experience",
    target: "_blank",
    rel: "noreferrer noopener"
  }, "document history"), ' ', "of each individual document to track these changes."))), dialogMode === 'delete' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Delete Documents"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$4.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Delete Documents",
      tone: "critical",
      disabled: loading,
      onClick: handleDelete
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$4.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to delete", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "Deleting a document makes it no longer available to the public as well as removing any draft versions of it."), /*#__PURE__*/React.createElement("p", null, /*#__PURE__*/React.createElement("strong", null, "Note:"), " in order to delete a document, it must not be referenced by any other document. You may have to remove those references first."))));
}

function createEmitter() {
  const listeners = new Set();

  function subscribe(listener) {
    listeners.add(listener);

    const unsubscribe = () => {
      listeners.delete(listener);
    };

    return unsubscribe;
  }

  function notify() {
    for (const listener of listeners) {
      listener();
    }
  }

  return {
    subscribe,
    notify
  };
}

const sanityClient = _client;
let client = sanityClient;

if (typeof sanityClient.withConfig === 'function') {
  client = sanityClient.withConfig({
    apiVersion: "1"
  });
}

var client$1 = client;

const removeDraftPrefix = s => s.startsWith('drafts.') ? s.substring('drafts.'.length) : s;

function usePaginatedClient({
  typeName,
  pageSize,
  selectedColumns,
  searchField,
  orderColumn
}) {
  // the loading statuses are a set of strings
  // when it's empty, nothing is loading
  const [loadingStatuses, setLoadingStatuses] = useState(new Set());
  const loading = loadingStatuses.size > 0; // stores the state for the total amount of de-duped documents

  const [total, setTotal] = useState(0); // uses the pageSize to calculate the total pages

  const totalPages = Math.ceil(total / pageSize); // stores the current set of active IDs on the page.
  // these are fed into the `useEffect` that creates the `results` state

  const [pageIds, setPageIds] = useState([]); // the current page. changing this will trigger a re-fetch of the `pageIds`

  const [page, setPage] = useState(0); // the current result set

  const [results, setResults] = useState([]); // used to force refresh. TODO: consider refactoring this

  const [refreshId, setRefreshId] = useState(nanoid());
  const refresh = useCallback(() => setRefreshId(nanoid()), []);
  const [userQuery, setUserQuery] = useState(''); // Builds the string to use when a custom filter has been entered

  const searchQuery = userQuery.length && searchField ? " && ".concat(searchField, " match \"").concat(userQuery, "*\"") : ''; // Implements ordering from the <th> buttons

  const orderQuery = orderColumn ? "| order(".concat(orderColumn.key, " ").concat(orderColumn.direction, ")") : ""; // get total count

  useEffect(() => {
    let canceled = false;

    async function getTotalCount() {
      // add the `total_count` to the loading statuses
      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('total_count');
        return next;
      }); // fetch all the draft IDs in this document type

      const draftIds = await client$1.fetch("*[_type == $typeName && _id in path(\"drafts.**\") ".concat(searchQuery, "]._id"), {
        typeName
      });
      const {
        draftsWithPublishedVersion,
        notDraftCount
      } = await client$1.fetch("{\n          \"draftsWithPublishedVersion\": *[_type == $typeName && _id in $ids ".concat(searchQuery, "]._id,\n          \"notDraftCount\": count(*[_type == $typeName && !(_id in path(\"drafts.**\")) ").concat(searchQuery, "]),\n        }"), {
        ids: draftIds.map(removeDraftPrefix),
        typeName
      }); // the calculation for the total is then:

      const total = draftIds.length - draftsWithPublishedVersion.length + notDraftCount; // early return on canceled

      if (canceled) return; // remove `total_count` from the loading statuses

      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.delete('total_count');
        return next;
      });
      setTotal(total);
    }

    getTotalCount().catch(e => {
      // TODO: proper error handling
      console.warn(e);
    });
    return () => {
      canceled = true;
    };
  }, [typeName, refreshId, searchQuery]); // get page IDs

  useEffect(() => {
    const getPageIds = async targetPage => {
      // add the `page_ids` to the loading statuses
      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('page_ids');
        return next;
      }); // query for all the draft IDs

      const draftIds = await client$1.fetch("*[_type == $typeName && _id in path(\"drafts.**\") ".concat(searchQuery, "]._id"), {
        typeName
      }); // create a set of drafts IDs.
      // these IDs are used to determine whether or a not a published version
      // should be ignored in order to favor the current draft version

      const drafts = draftIds.reduce((set, next) => {
        set.add(removeDraftPrefix(next));
        return set;
      }, new Set()); // this is a recursive function that will call itself until it reaches the
      // desired page.
      //
      // TODO: this implementation gets slower with each new page. pagination
      // is relatively challenging in this context since there could or could
      // not be a draft. The published version should be ignored to prefer the
      // draft which makes it hard to know where the current page ends and the
      // next one begins

      const getPage = async (start = 0, page = 0) => {
        const end = start + // note: we fetch twice the given page size to consider the cases
        // where we have to remove half the result set in the case of
        // duplicate `draft.` document
        pageSize * 2;
        const pageIds = await client$1.fetch("*[_type == $typeName ".concat(searchQuery, "]").concat(orderQuery, "[$start...$end]._id"), {
          typeName,
          start,
          end
        });
        const filteredIds = pageIds.map((id, index) => ({
          id,
          index: start + index
        })).filter(({
          id
        }) => {
          // if the id is a draft ID, we want to keep it
          if (id.startsWith('drafts.')) return true; // if the published _id exists in `drafts`, then there exists a draft
          // version of the current document and we should prefer that over the
          // published version

          if (drafts.has(id)) return false;
          return true;
        }).slice(0, pageSize);
        const ids = filteredIds.map(i => i.id).map(removeDraftPrefix);
        if (page >= targetPage) return ids;
        const last = filteredIds[filteredIds.length - 1];
        if (!last) return [];
        return await getPage(last.index + 1, page + 1);
      };

      const ids = await getPage(); // delete the `page_ids` from the loading statuses

      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.delete('page_ids');
        return next;
      });
      return ids;
    };

    getPageIds(page).then(setPageIds).catch(e => {
      // TODO: proper error handling
      console.warn(e);
    });
  }, [page, pageSize, typeName, refreshId, searchQuery, orderQuery]); // get results

  useEffect(() => {
    // take all the input IDs and duplicate them with the prefix `drafts.`
    const ids = pageIds.map(id => [id, "drafts.".concat(id)]).flat(); // Inner-object selected keys need to be shaped in the query

    const columnKeys = Array.from(selectedColumns).map(key => key.includes('.') ? "\"".concat(key, "\": ").concat(key) : key).join(', '); // these IDs will go into a specific query. if the draft or published
    // version happens to not exist, that's okay.

    const query = "*[_id in $ids ".concat(searchQuery, "]").concat(orderQuery, "{ _id, _type, ").concat(columnKeys, " }"); // console.log(query);

    async function getResults() {
      // add the `results` to the loading statuses
      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('results');
        return next;
      }); // create a dictionary of indexes where the keys are the IDs and the
      // values are the current index. this dictionary will be used to sort the
      // documents in their original order

      const indexes = pageIds.reduce((acc, id, index) => {
        acc[id] = index;
        return acc;
      }, {});
      const results = await client$1.fetch(query, {
        ids
      }); // reduce the results into an accumulator by their normalized ID.
      // if there is a draft version, prefer the draft over the published

      const reducedResults = Object.values(results.reduce((acc, next) => {
        const id = removeDraftPrefix(next._id);
        const current = acc[id];
        const currentIsDraft = current === null || current === void 0 ? void 0 : current._id.startsWith('drafts.');
        const nextIsDraft = next === null || next === void 0 ? void 0 : next._id.startsWith('drafts.');
        const status = current && next ? 'draft' : currentIsDraft || nextIsDraft ? 'unpublished' : 'published';
        acc[id] = currentIsDraft ? current : next;
        acc[id]._status = status;
        acc[id]._normalizedId = id;
        return acc;
      }, {})); // delete the `results` from the loading statuses

      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.delete('results');
        return next;
      });
      setResults(reducedResults.slice() // sort the accumulated version by their original index
      .sort((a, b) => indexes[removeDraftPrefix(a._id)] - indexes[removeDraftPrefix(b._id)]));
    } // TODO: consider error handling


    getResults().catch(e => {
      console.warn(e);
    }); // TODO: add error handler
    // Listen to changes across the entire type

    const typeQuery = "*[_type == $typeName]";
    const subscription = client$1.listen(typeQuery, {
      typeName
    }).pipe(tap(result => {
      // Add a new id to the array if a new doc was created
      const docId = result.documentId.replace('drafts.', '');

      if (!pageIds.includes(docId)) {
        setPageIds([...pageIds, docId]);
      } // add the `results` to the loading statuses


      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('results');
        return next;
      });
    }), debounceTime(1000)).subscribe(getResults);
    return () => subscription.unsubscribe();
  }, [pageIds, selectedColumns, refreshId, searchQuery, orderQuery]); // reset page

  useEffect(() => {
    // if the page is greater than the total pages then reset the page.
    // this could occur if the page size changed
    if (page >= totalPages) {
      setPage(0);
    }
  }, [page, totalPages]);
  return {
    results,
    page,
    totalPages,
    setPage,
    loading,
    pageIds,
    total,
    refresh,
    setUserQuery
  };
}

var css_248z$3 = ".styles-module_list__2jRsa {\n  display: flex;\n  flex-direction: column;\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n}\n\n.styles-module_label__3hcyN {\n  padding: 1rem;\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n}\n\n.styles-module_label__3hcyN:hover {\n  background-color: #f1f3f6;\n}\n\n.styles-module_label__3hcyN:active {\n  background-color: #e4e8ed;\n}\n\n.styles-module_checkbox__37qrf {\n  margin-right: space(2);\n}\n\n.styles-module_footer__3AnCj {\n  display: flex;\n  gap: 0.5rem;\n  justify-content: flex-end;\n  padding: 0.5rem;\n}\n";
var styles$3 = {"list":"styles-module_list__2jRsa","label":"styles-module_label__3hcyN","checkbox":"styles-module_checkbox__37qrf","footer":"styles-module_footer__3AnCj"};
styleInject(css_248z$3);

function getInnerFields(childFields, parentPath, currentLevel = 1) {
  return childFields.reduce((acc, cur) => {
    var _cur$type, _cur$type$fields;

    const fieldPath = parentPath + '.' + cur.name;
    const level = currentLevel + 1;
    const child = {
      field: cur,
      fieldPath,
      title: cur.type.title,
      level,
      sortable: true
    };

    if ((_cur$type = cur.type) !== null && _cur$type !== void 0 && (_cur$type$fields = _cur$type.fields) !== null && _cur$type$fields !== void 0 && _cur$type$fields.length) {
      child.sortable = false;
      const children = cur.type.fields;
      const innerFields = getInnerFields(children, fieldPath, level);

      if (innerFields.length) {
        return [...acc, child, ...innerFields];
      }
    }

    return [...acc, child];
  }, []);
}

function getSelectableFields(fields = []) {
  if (!fields.length) return [];
  const selectable = fields.reduce((acc, cur) => {
    var _cur$type2, _cur$type2$fields;

    const fieldPath = cur.name;
    const title = cur.type.title;
    const parent = {
      field: cur,
      fieldPath,
      title,
      level: 0,
      sortable: true
    };

    if ((_cur$type2 = cur.type) !== null && _cur$type2 !== void 0 && (_cur$type2$fields = _cur$type2.fields) !== null && _cur$type2$fields !== void 0 && _cur$type2$fields.length) {
      parent.sortable = false;
      const children = cur.type.fields;
      const innerFields = getInnerFields(children, fieldPath, 1);

      if (innerFields.length) {
        return [...acc, parent, ...innerFields];
      }
    }

    return [...acc, parent];
  }, []);
  return selectable;
}

function ColumnSelector({
  open,
  onClose,
  onSelect,
  typeName,
  initiallySelectedColumns
}) {
  const schemaType = schema.get(typeName);
  const [selectedColumns, setSelectedColumns] = useState(initiallySelectedColumns);
  useEffect(() => {
    if (open) {
      setSelectedColumns(initiallySelectedColumns);
    }
  }, [open, initiallySelectedColumns]);
  const dialogId = useMemo(() => nanoid(), []);

  function handleSelect(fieldPath) {
    setSelectedColumns(set => {
      const nextSet = new Set(set);

      if (set.has(fieldPath)) {
        nextSet.delete(fieldPath);
      } else {
        nextSet.add(fieldPath);
      }

      return nextSet;
    });
  }

  const selectableFields = useMemo(() => getSelectableFields(schemaType.fields), [schemaType.fields]);

  if (!open) {
    return null;
  }

  return /*#__PURE__*/React.createElement(Dialog, {
    className: styles$3.dialog,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Select Columns"),
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$3.footer
    }, /*#__PURE__*/React.createElement(Button, {
      mode: "ghost",
      text: "Cancel",
      onClick: onClose
    }), /*#__PURE__*/React.createElement(Button, {
      tone: "primary",
      text: "Apply",
      onClick: () => {
        onClose();
        onSelect(selectedColumns);
      }
    })),
    id: dialogId,
    onClose: onClose,
    zOffset: 100000
  }, /*#__PURE__*/React.createElement("ul", {
    className: styles$3.list
  }, /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("label", {
    className: styles$3.label
  }, /*#__PURE__*/React.createElement(Checkbox, {
    className: styles$3.checkbox,
    checked: selectedColumns.has('_updatedAt'),
    onChange: () => handleSelect('_updatedAt')
  }), /*#__PURE__*/React.createElement("span", null, "Updated At"))), selectableFields.map(({
    fieldPath,
    title,
    level
  }) => /*#__PURE__*/React.createElement("li", {
    key: fieldPath,
    style: {
      marginLeft: level * 10
    }
  }, /*#__PURE__*/React.createElement("label", {
    className: styles$3.label
  }, /*#__PURE__*/React.createElement(Checkbox, {
    className: styles$3.checkbox,
    checked: selectedColumns.has(fieldPath),
    onChange: () => handleSelect(fieldPath)
  }), /*#__PURE__*/React.createElement("span", null, title))))));
}

/**
 * Converts portable text to strings.
 *
 * Copied and pasted from:
 * https://www.sanity.io/docs/presenting-block-text#plain-text-serialization-ac67a867dd69
 */
function blockContentToString(blocks = []) {
  return blocks // loop through each block
  .map(block => {
    // if it's not a text block with children,
    // return nothing
    if (block._type !== 'block' || !block.children) {
      return '';
    } // loop through the children spans, and join the
    // text strings


    return block.children.map(child => child.text).join('');
  }) // join the paragraphs leaving split by two linebreaks
  .join('\n\n');
}

var css_248z$2 = ".styles-module_blockContent__2VzDe {\n  max-width: 300px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n";
var styles$2 = {"blockContent":"styles-module_blockContent__2VzDe"};
styleInject(css_248z$2);

function Cell({
  field,
  fieldPath,
  value
}) {
  switch (field.type.name) {
    // Hacky! Format _just_ the updatedAt field
    case '_updatedAt':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: fieldPath
        }, /*#__PURE__*/React.createElement(Text, {
          size: 1
        }, new Date(value).toLocaleString()));
      }
    // The rest of these types are legit!

    case 'string':
    case 'number':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: fieldPath
        }, value);
      }

    case 'blockContent':
      {
        const blockContentAsString = blockContentToString(value);
        return /*#__PURE__*/React.createElement("td", {
          title: blockContentAsString,
          key: fieldPath,
          className: styles$2.blockContent
        }, blockContentAsString);
      }

    case 'datetime':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: fieldPath
        }, value ? new Date(value).toLocaleString() : '');
      }

    case 'date':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: fieldPath
        }, value ? new Date(value).toLocaleDateString() : '');
      }

    case 'array':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: fieldPath
        }, (value === null || value === void 0 ? void 0 : value.length) || 0, " item", (value === null || value === void 0 ? void 0 : value.length) === 1 ? '' : 's');
      }

    default:
      {
        return /*#__PURE__*/React.createElement("td", {
          key: fieldPath
        }, value && /*#__PURE__*/React.createElement(SanityPreview, {
          type: field.type,
          layout: "default",
          value: value
        }));
      }
  }
}

var css_248z$1 = "* {\n  box-sizing: border-box;\n}\n\n.styles-module_container__FDcY6 {\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n.styles-module_tableWrapper__1fePr {\n  flex: 1 1 auto;\n  overflow: auto;\n  position: relative;\n  padding-bottom: 200px;\n  max-height: 100%;\n}\n\n.styles-module_loadingOverlay__1l4lq {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  left: 0;\n  right: 0;\n  pointer-events: none;\n  transition: opacity 250ms;\n  background-color: white;\n  z-index: 5;\n  opacity: 0;\n  display: flex;\n}\n\n.styles-module_loadingOverlayActive__1HgQR {\n  opacity: 0.5;\n}\n\n.styles-module_loadingSpinner__2nd5w {\n  margin: auto;\n  width: 32px;\n  height: 32px;\n  -webkit-animation: styles-module_spin__2XTVD 1500ms linear infinite;\n          animation: styles-module_spin__2XTVD 1500ms linear infinite;\n}\n\n@-webkit-keyframes styles-module_spin__2XTVD {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes styles-module_spin__2XTVD {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n.styles-module_table__xXetw {\n  border-collapse: collapse;\n  min-width: 100%;\n}\n\n.styles-module_table__xXetw td,\n.styles-module_table__xXetw th {\n  padding: 0.5rem 1rem;\n  text-align: left;\n}\n\n.styles-module_tbody__3-ba9 tr td {\n  border-bottom: 1px solid #ced2d9;\n}\n\n.styles-module_thead__3tFqM th {\n  padding: 1rem;\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0;\n  text-align: left;\n  background: rgba(255, 255, 255, 0.95);\n  z-index: 1;\n}\n\n.styles-module_tbody__3-ba9 td {\n  cursor: pointer;\n}\n\n.styles-module_thead__3tFqM th::after {\n  position: absolute;\n  content: ' ';\n  left: 0;\n  right: 0;\n  bottom: 0;\n  top: 0;\n  border-bottom: 1px solid #ced2d9;\n  pointer-events: none;\n}\n\n.styles-module_tbody__3-ba9 tr:hover td {\n  background-color: #f1f3f6;\n}\n\n.styles-module_tbody__3-ba9 tr:active td {\n  background-color: #e4e8ed;\n}\n\n.styles-module_footer__3aF_x {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  gap: 1rem;\n  padding: 0.5rem;\n  border-top: 1px solid #ced2d9;\n  position: absolute;\n  bottom: 0;\n  background: rgba(255, 255, 255, 0.95);\n}\n\n.styles-module_selectLabel__29LqI {\n  display: flex;\n  gap: 1rem;\n  align-items: center;\n}\n\n.styles-module_select__3p5dI {\n  width: 75px;\n}\n\n.styles-module_table__xXetw .styles-module_optionsCell__1G2nN {\n  text-align: right;\n}\n\n.styles-module_menu__1wrFP {\n  text-align: left;\n}\n\n.styles-module_table__xXetw .styles-module_titleCell__12IYo {\n  max-width: 232px;\n  padding-left: 0;\n}\n\n.styles-module_checkboxCell__2Jvje {\n  width: 30px;\n  overflow: hidden;\n  position: relative;\n}\n\n.styles-module_hiddenCheckbox__fMwJO {\n  height: 100%;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  width: 100%;\n  opacity: 0;\n  cursor: pointer;\n}\n\n.styles-module_checkboxFacade__2BFqv {\n  display: flex;\n  pointer-events: none;\n}\n\n.styles-module_checkboxCell__2Jvje > * > * {\n  margin: auto;\n}\n\n.styles-module_statusIcon__1aqP9 {\n  width: 24px;\n  height: 24px;\n}\n";
var styles$1 = {"container":"styles-module_container__FDcY6","tableWrapper":"styles-module_tableWrapper__1fePr","loadingOverlay":"styles-module_loadingOverlay__1l4lq","loadingOverlayActive":"styles-module_loadingOverlayActive__1HgQR","loadingSpinner":"styles-module_loadingSpinner__2nd5w","spin":"styles-module_spin__2XTVD","table":"styles-module_table__xXetw","tbody":"styles-module_tbody__3-ba9","thead":"styles-module_thead__3tFqM","footer":"styles-module_footer__3aF_x","selectLabel":"styles-module_selectLabel__29LqI","select":"styles-module_select__3p5dI","optionsCell":"styles-module_optionsCell__1G2nN","menu":"styles-module_menu__1wrFP","titleCell":"styles-module_titleCell__12IYo","checkboxCell":"styles-module_checkboxCell__2Jvje","hiddenCheckbox":"styles-module_hiddenCheckbox__fMwJO","checkboxFacade":"styles-module_checkboxFacade__2BFqv","statusIcon":"styles-module_statusIcon__1aqP9"};
styleInject(css_248z$1);

var css_248z = ".styles-module_searchForm__1VwhC {\n  margin: 0.5rem;\n  display: flex;\n  gap: 1rem;\n}\n\n.styles-module_searchSelect__ofD9q {\n  width: 5rem;\n}";
var styles = {"searchForm":"styles-module_searchForm__1VwhC","searchSelect":"styles-module_searchSelect__ofD9q"};
styleInject(css_248z);

function SearchField({
  currentField,
  fieldsToChooseFrom,
  onSearch,
  onFieldSelected
}) {
  const [userQuery, setUserQuery] = useState('');
  useEffect(() => {
    if (!userQuery.length) {
      onSearch('');
      return;
    }

    const timeout = setTimeout(() => {
      onSearch(userQuery);
    }, 700);
    return () => clearTimeout(timeout);
  }, [userQuery, onSearch]);

  if (!(fieldsToChooseFrom !== null && fieldsToChooseFrom !== void 0 && fieldsToChooseFrom.length)) {
    return /*#__PURE__*/React.createElement(Box, {
      padding: 3
    }, /*#__PURE__*/React.createElement(Card, {
      tone: "caution",
      padding: 3,
      radius: 2,
      shadow: 1
    }, /*#__PURE__*/React.createElement(Text, null, "No Searchable Fields to select from")));
  }

  return /*#__PURE__*/React.createElement("form", {
    onSubmit: e => e.preventDefault(),
    className: styles.searchForm
  }, /*#__PURE__*/React.createElement(TextInput, {
    onChange: event => setUserQuery(event.currentTarget.value),
    placeholder: "Search",
    value: userQuery
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.searchSelect
  }, /*#__PURE__*/React.createElement(Select, {
    value: currentField || undefined,
    onChange: e => onFieldSelected(e.currentTarget.value)
  }, fieldsToChooseFrom.map(field => /*#__PURE__*/React.createElement("option", {
    key: field.name,
    value: field.name
  }, field.title)))));
}

function useStickyStateSet(defaultValue, key) {
  const [value, setValue] = useState(() => {
    const stickyValue = window.localStorage.getItem(key);
    return stickyValue !== null ? new Set(JSON.parse(stickyValue)) : defaultValue;
  });
  useEffect(() => {
    if (value) {
      window.localStorage.setItem(key, JSON.stringify(Array.from(value)));
    }
  }, [key, value]);
  return [value, setValue];
}

function useStickyStateOrder(defaultValue, key) {
  const [value, setValue] = useState(() => {
    const stickyValue = window.localStorage.getItem(key);
    return stickyValue !== null ? JSON.parse(stickyValue) : defaultValue;
  });
  useEffect(() => {
    if (value) {
      window.localStorage.setItem(key, JSON.stringify(value));
    }
  }, [key, value]);
  return [value, setValue];
}

function TableHeaderInner({
  field,
  orderColumn
}) {
  return /*#__PURE__*/React.createElement(Flex, {
    align: "center"
  }, /*#__PURE__*/React.createElement(Label, {
    muted: !field.sortable
  }, field.title), field.sortable && /*#__PURE__*/React.createElement(React.Fragment, null, orderColumn.key === field.fieldPath ? /*#__PURE__*/React.createElement(React.Fragment, null, orderColumn.direction === 'asc' ? /*#__PURE__*/React.createElement(ChevronDownIcon, null) : /*#__PURE__*/React.createElement(ChevronUpIcon, null)) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SortIcon, null))));
}

function parentHasClass(el, className) {
  if (!el) return false;
  if (el.classList.contains(className)) return true;
  return parentHasClass(el.parentElement, className);
}

function createSuperPane(typeName) {
  const schemaType = schema.get(typeName);
  const selectColumns = createEmitter();
  const refresh = createEmitter();
  const search = createEmitter();
  const fieldsToChooseFrom = schemaType.fields.filter(field => {
    var _field$type;

    return (field === null || field === void 0 ? void 0 : (_field$type = field.type) === null || _field$type === void 0 ? void 0 : _field$type.jsonType) === 'string';
  }).map(field => ({
    name: field.name,
    title: field.type.title
  }));
  const rowsPerPage = [25, 50, 100, 250, 500];
  const orderColumnDefault = {
    key: '',
    direction: 'asc'
  };

  function SuperPane() {
    var _fieldsToChooseFrom$;

    const router = useRouter();
    const [pageSize, setPageSize] = useState(rowsPerPage[0]);
    const [columnSelectorOpen, setColumnSelectorOpen] = useState(false);
    const [selectedColumns, setSelectedColumns] = useStickyStateSet(new Set(), "super-pane-".concat(typeName, "-selected-columns"));
    const [orderColumn, setOrderColumn] = useStickyStateOrder(orderColumnDefault, "super-pane-".concat(typeName, "-order-column"));
    const [selectedIds, setSelectedIds] = useState(new Set());
    const [selectedSearchField, setSelectedSearchField] = useState(fieldsToChooseFrom !== null && fieldsToChooseFrom !== void 0 && fieldsToChooseFrom.length ? (_fieldsToChooseFrom$ = fieldsToChooseFrom[0]) === null || _fieldsToChooseFrom$ === void 0 ? void 0 : _fieldsToChooseFrom$.name : null);
    const [showSearch, setShowSearch] = useState(false);
    const containerRef = useRef(null);
    const client = usePaginatedClient({
      typeName,
      pageSize,
      selectedColumns,
      searchField: selectedSearchField,
      orderColumn
    });
    useEffect(() => {
      return selectColumns.subscribe(() => setColumnSelectorOpen(true));
    }, []);
    useEffect(() => {
      return refresh.subscribe(client.refresh);
    }, [client.refresh]);
    useEffect(() => {
      return search.subscribe(() => setShowSearch(prev => !prev));
    }, []);
    const defaultFields = selectedColumns.has('_updatedAt') ? [{
      fieldPath: '_updatedAt',
      title: 'Updated At',
      field: {
        type: {
          name: '_updatedAt'
        }
      },
      level: 0,
      sortable: true
    }] : [];
    const selectableFields = useMemo(() => getSelectableFields(schemaType.fields).filter(field => selectedColumns.has(field.fieldPath)), [selectedColumns]);
    const fields = [...defaultFields, ...selectableFields];
    const atLeastOneSelected = client.results.some(i => selectedIds.has(i._normalizedId));
    const allSelected = client.results.every(i => selectedIds.has(i._normalizedId));

    function handleOrder(key) {
      // Reset
      if (orderColumn.key === key && orderColumn.direction === 'desc') {
        return setOrderColumn(orderColumnDefault);
      } // Set updated key and/or direction


      setOrderColumn({
        key,
        direction: (orderColumn === null || orderColumn === void 0 ? void 0 : orderColumn.direction) === 'asc' && orderColumn.key === key ? 'desc' : 'asc'
      });
    }

    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      ref: containerRef,
      className: styles$1.container
    }, /*#__PURE__*/React.createElement(Card, {
      padding: 3,
      tone: selectedIds.size < 1 ? "transparent" : "positive",
      shadow: 1
    }, /*#__PURE__*/React.createElement(Flex, {
      align: "center"
    }, /*#__PURE__*/React.createElement(Button, {
      disabled: selectedIds.size < 1,
      onClick: () => setSelectedIds(new Set()),
      fontSize: 1,
      paddingY: 1,
      paddingX: 2
    }, "Clear"), /*#__PURE__*/React.createElement(Box, {
      paddingX: 2,
      style: {
        marginRight: 'auto'
      }
    }, /*#__PURE__*/React.createElement(Text, {
      size: 1,
      weight: "bold"
    }, selectedIds.size, " item", selectedIds.size === 1 ? '' : 's', ' ', "selected")), /*#__PURE__*/React.createElement(BulkActionsMenu, {
      disabled: selectedIds.size < 1,
      className: styles$1.clearButton,
      selectedIds: selectedIds,
      typeName: typeName,
      onDelete: () => {
        setSelectedIds(new Set());
        client.setPage(0);
        client.refresh();
      }
    }))), showSearch && /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(SearchField, {
      currentField: selectedSearchField,
      fieldsToChooseFrom: fieldsToChooseFrom,
      onSearch: client.setUserQuery,
      onFieldSelected: setSelectedSearchField
    })), /*#__PURE__*/React.createElement("div", {
      className: classNames(styles$1.loadingOverlay, {
        [styles$1.loadingOverlayActive]: client.loading
      })
    }, /*#__PURE__*/React.createElement(SpinnerIcon, {
      className: styles$1.loadingSpinner
    })), /*#__PURE__*/React.createElement("div", {
      className: styles$1.tableWrapper
    }, /*#__PURE__*/React.createElement("table", {
      className: styles$1.table
    }, /*#__PURE__*/React.createElement("thead", {
      className: styles$1.thead
    }, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("th", {
      className: classNames(styles$1.checkboxCell, 'prevent-nav')
    }, /*#__PURE__*/React.createElement("input", {
      type: "checkbox",
      className: styles$1.hiddenCheckbox,
      onChange: () => {
        setSelectedIds(set => {
          const nextSet = new Set(set);

          if (allSelected) {
            for (const result of client.results || []) {
              nextSet.delete(result._normalizedId);
            }
          } else {
            for (const result of client.results || []) {
              nextSet.add(result._normalizedId);
            }
          }

          return nextSet;
        });
      },
      checked: allSelected
    }), /*#__PURE__*/React.createElement("div", {
      "aria-hidden": "true",
      className: styles$1.checkboxFacade
    }, /*#__PURE__*/React.createElement(Checkbox, {
      tabIndex: -1,
      checked: atLeastOneSelected,
      indeterminate: atLeastOneSelected && !allSelected
    }))), /*#__PURE__*/React.createElement("th", {
      style: {
        paddingLeft: 0
      }
    }, /*#__PURE__*/React.createElement(Label, null, schemaType.title)), /*#__PURE__*/React.createElement("th", null, /*#__PURE__*/React.createElement(Label, null, "Status")), fields.map(field => /*#__PURE__*/React.createElement("th", {
      key: field.fieldPath
    }, field.sortable ? /*#__PURE__*/React.createElement(Button, {
      mode: orderColumn.key !== field.fieldPath ? 'bleed' : 'default',
      tone: orderColumn.key === field.fieldPath ? 'primary' : 'default',
      padding: 1,
      onClick: () => handleOrder(field.fieldPath)
    }, /*#__PURE__*/React.createElement(TableHeaderInner, {
      field: field,
      orderColumn: orderColumn
    })) : /*#__PURE__*/React.createElement(TableHeaderInner, {
      field: field,
      orderColumn: orderColumn
    }))), /*#__PURE__*/React.createElement("th", {
      className: styles$1.optionsCell,
      "aria-label": "Options"
    }))), /*#__PURE__*/React.createElement("tbody", {
      className: styles$1.tbody
    }, client.results.map(item => {
      const handleNavigation = () => {
        router.navigateUrl(router.resolveIntentLink('edit', {
          id: item._id,
          type: item._type
        }));
      };

      return /*#__PURE__*/React.createElement("tr", {
        key: item._normalizedId,
        onClick: e => {
          // prevent the menu button from causing a navigation
          if (parentHasClass(e.target, 'prevent-nav')) {
            return;
          }

          handleNavigation();
        }
      }, /*#__PURE__*/React.createElement("td", {
        className: classNames(styles$1.checkboxCell, 'prevent-nav')
      }, /*#__PURE__*/React.createElement("input", {
        type: "checkbox",
        className: styles$1.hiddenCheckbox,
        onChange: e => {
          setSelectedIds(set => {
            const nextSet = new Set(set);

            if (e.currentTarget.checked) {
              nextSet.add(item._normalizedId);
            } else {
              nextSet.delete(item._normalizedId);
            }

            return nextSet;
          });
        },
        checked: selectedIds.has(item._normalizedId)
      }), /*#__PURE__*/React.createElement("div", {
        "aria-hidden": "true",
        className: styles$1.checkboxFacade
      }, /*#__PURE__*/React.createElement(Checkbox, {
        tabIndex: -1,
        checked: selectedIds.has(item._normalizedId)
      }))), /*#__PURE__*/React.createElement("td", {
        className: styles$1.titleCell
      }, /*#__PURE__*/React.createElement(SanityPreview, {
        type: schemaType,
        layout: "default",
        value: item
      })), /*#__PURE__*/React.createElement("td", null, /*#__PURE__*/React.createElement(Badge, {
        fontSize: 0,
        tone: item._status === 'published' ? 'positive' : item._status === 'unpublished' ? 'caution' : 'default'
      }, item._status)), fields.map(field => /*#__PURE__*/React.createElement(Cell, {
        field: field.field,
        fieldPath: field.fieldPath,
        value: get(item, field.fieldPath)
      })), /*#__PURE__*/React.createElement("td", {
        className: styles$1.optionsCell
      }, /*#__PURE__*/React.createElement(MenuButton, {
        button: /*#__PURE__*/React.createElement(Button, {
          className: "prevent-nav",
          icon: EllipsisVerticalIcon,
          title: "Options",
          mode: "bleed"
        }),
        portal: true,
        id: "prevent-nav-example",
        menu: /*#__PURE__*/React.createElement(Menu, {
          className: styles$1.menu
        }, /*#__PURE__*/React.createElement(MenuItem, {
          className: "prevent-nav",
          text: "Open",
          icon: ArrowRightIcon,
          onClick: handleNavigation
        })),
        placement: "left"
      })));
    })))), /*#__PURE__*/React.createElement(Card, {
      borderTop: true,
      style: {
        position: "absolute",
        bottom: 0,
        width: "100%"
      },
      padding: 3
    }, /*#__PURE__*/React.createElement(Flex, {
      align: "center",
      gap: 2
    }, /*#__PURE__*/React.createElement(Flex, {
      align: "center",
      gap: 2
    }, /*#__PURE__*/React.createElement(Label, {
      style: {
        whiteSpace: "nowrap"
      }
    }, "Rows Per Page"), /*#__PURE__*/React.createElement(Select, {
      value: pageSize,
      onChange: e => setPageSize(parseInt(e.currentTarget.value, 10))
    }, rowsPerPage.map(count => /*#__PURE__*/React.createElement("option", {
      key: count,
      value: count
    }, count)))), /*#__PURE__*/React.createElement(Box, {
      flex: 1
    }, /*#__PURE__*/React.createElement(Flex, {
      align: "center",
      justify: "flex-end",
      gap: 2
    }, /*#__PURE__*/React.createElement(Button, {
      fontSize: 1,
      disabled: client.page === 0,
      onClick: () => client.setPage(client.page - 1),
      icon: ChevronLeftIcon,
      title: "Previous page",
      mode: "bleed"
    }), /*#__PURE__*/React.createElement(Label, null, client.totalPages === 0 ? 0 : client.page + 1, "\xA0/\xA0", client.totalPages), /*#__PURE__*/React.createElement(Button, {
      fontSize: 1,
      disabled: client.page >= client.totalPages - 1,
      onClick: () => client.setPage(client.page + 1),
      icon: ChevronRightIcon,
      title: "Next Page",
      mode: "bleed"
    })))))), /*#__PURE__*/React.createElement(ColumnSelector, {
      open: columnSelectorOpen // open={true}
      ,
      onClose: () => setColumnSelectorOpen(false),
      typeName: typeName,
      initiallySelectedColumns: selectedColumns,
      onSelect: setSelectedColumns
    }));
  }

  function SuperPaneWrapper() {
    return /*#__PURE__*/React.createElement(RouterProvider, null, /*#__PURE__*/React.createElement(SuperPane, null));
  }

  return Object.assign(S.documentTypeList(typeName).serialize(), {
    type: 'component',
    component: SuperPaneWrapper,
    menuItems: S.documentTypeList(typeName).menuItems([S.menuItem().title('Refresh').icon(SyncIcon).action(refresh.notify), S.menuItem().title('Search').icon(SearchIcon).action(search.notify), S.menuItem().title('Select Columns').icon(ControlsIcon).action(selectColumns.notify)].filter(Boolean)).serialize().menuItems
  });
}

export { createSuperPane };
//# sourceMappingURL=index.esm.js.map
